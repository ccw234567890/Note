![[屏幕截图 2025-08-12 162231.png]]

![[屏幕截图 2025-08-12 162241 1.png]]

![[屏幕截图 2025-08-12 162252 1.png]]

![[屏幕截图 2025-08-12 162302 1.png]]

![[屏幕截图 2025-08-12 162312 1.png]]

![[屏幕截图 2025-08-12 162407 1.png]]

![[屏幕截图 2025-08-12 162421 1.png]]

![[屏幕截图 2025-08-12 162429 1.png]]


# 笔记：I2C (Inter-Integrated Circuit) 协议全解析

> [!abstract] 核心纲要
> 本笔记旨在深入剖析**I2C (集成电路互联总线)** 的核心概念与工作原理。我们将重点关注：
> 1.  **I2C是什么**: 了解其作为一种**同步、串行、双线制**通信协议的定位。
> 2.  **I2C的核心架构**: 解析其**主从 (Master/Slave)** 角色、**地址寻址**机制以及独特的**开漏/上拉电阻**物理层。
> 3.  **I2C的工作原理**: 理解其数据传输的基本流程和**ACK应答机制**。
> 4.  **I2C的特性总结**: 全面了解其速度、设备容量等关键指标。

---

### Ⅰ. I2C是什么？- 简约高效的板内通信

> [!info]
> - **全称**: **I²C** (或 IIC) - **Inter-Integrated Circuit** (集成电路互联总线)。
> - **开发者**: 由飞利浦半导体（Philips Semiconductor）在1982年开发。
> - **定义**: 一种**同步、串行**通信协议，仅使用**两根线**即可在**同一块电路板 (PCB)** 上的多个集成电路之间进行**短距离**通信。
> - **核心优势**: 结合了**UART的简约（线少）**和类似**SPI的多设备连接能力**。非常适合连接各种中低速的外围设备，如传感器、EEPROM存储器和RTC实时时钟等。

---

### Ⅱ. I2C的核心架构

> [!example]
> I2C的架构设计精巧，通过两根线实现了复杂的多设备通信网络。

> [!check] **1. 两根双向信号线**
> > - **SDA (Serial Data Line)**: **串行数据线**，用于双向传输数据。
> > - **SCL (Serial Clock Line)**: **串行时钟线**，由主设备产生和控制，用于同步所有的数据传输。

> [!check] **2. 主从设备角色 (Master/Slave Roles)**
> > - **主设备 (Master)**:
> >   - **发起**并**终止**通信。
> >   - **产生**并**控制**SCL时钟信号。
> >   - 通过发送地址来**选择**一个从设备进行通信。
> >   - I2C总线**支持多个主设备**（Multi-master）。
> > - **从设备 (Slave)**:
> >   - **被动**地等待被主设备通过其唯一地址“点名”。
> >   - **响应**主设备的读/写请求。
> >   - **不产生**时钟信号。

> [!check] **3. 基于地址 (Address-based) 的系统**
> > - 总线上的**每一个从设备**都有一个**唯一的、预先设定的地址**（通常是7位或10位）。
> > - 主设备通过在通信开始时广播这个地址，来实现对特定从设备的精准选择。

> [!warning] **4. 物理层：开漏输出 (Open-Drain) 与上拉电阻**
> > - **这是I2C能够用两根线连接多个设备的关键**。
> > - **开漏输出**: I2C设备内部的引脚只能将总线**拉向低电平 (GND)**，但**无法**主动输出高电平。
> > - **上拉电阻 (Pull-up Resistors)**: **必须**在SDA和SCL线上各连接一个**外部上拉电阻**到电源 (Vcc)。当总线上没有任何设备“拉低”线路时，这两个电阻会自动将线路的电平**“拉高”到高电平**，作为总线的默认空闲状态。

---

### Ⅲ. I2C的工作原理

> [!help]
> 一次完整的I2C通信，就像一次结构严谨的“对话”。

1. **发起通信**: **主设备**通过一个特殊的**起始条件 (Start Condition)**来获得总线控制权。
2. **寻址**: 主设备在SDA线上广播它想要通信的**从设备地址**，以及一个**读/写方向位**。
3. **从设备响应**: 总线上所有从设备都会监听地址。地址匹配的那个从设备会**响应**主设备。
4. **数据传输**: 数据以**8位的字节 (Byte)** 为单位进行传输。
5. **ACK/NACK 确认机制**: **每传输完一个字节**后，**接收方**都会发送一个**1位的应答信号 (Acknowledgment, ACK)** 来确认已成功接收。这是保证I2C通信可靠性的核心机制。
6. **结束通信**: 数据传输完毕后，**主设备**通过一个**停止条件 (Stop Condition)**来释放总线。

---

### Ⅳ. I2C的特性总结

> [!summary]

| 特性 (Feature)           | 详细信息 (Details)                                                              |
| :--------------------- | :-------------------------------------------------------------------------- |
| **引脚数量 (Wires Used)**  | **2** (SDA, SCL)                                                            |
| **最大速度 (Max Speed)**   | - 标准模式: 100 kbps<br>- 快速模式: 400 kbps<br>- 高速模式: 3.4 Mbps<br>- 超快速模式: 5 Mbps |
| **类型 (Type)**          | 同步 (Synchronous)                                                            |
| **数据格式 (Data Format)** | 串行 (Serial)                                                                 |
| **最大主设备数**             | 无限制 (Unlimited)                                                             |
| **最大从设备数**             | **1008** (使用10位寻址)                                                          |


![[屏幕截图 2025-08-12 162436 1.png]]

![[屏幕截图 2025-08-12 162449 1.png]]

![[屏幕截图 2025-08-12 162457 1.png]]

![[屏幕截图 2025-08-12 162506 1.png]]

![[屏幕截图 2025-08-12 162515 1.png]]

![[屏幕截图 2025-08-12 162525 1.png]]

![[屏幕截图 2025-08-12 162534 1.png]]

![[屏幕截图 2025-08-12 162546 1.png]]


# 笔记：I2C工作原理深度解析 - 从开漏输出到消息帧

> [!abstract] 核心纲要
> 本笔记旨在深入剖析**I2C (集成电路互联总线)** 的核心工作原理。我们将重点关注：
> 1.  **I2C的物理层**: 详细解析其独特的**开漏 (Open-Drain)** 输出结构与**上拉电阻**的必要性，以及由此产生的“线与”逻辑。
> 2.  **I2C的消息结构**: 全面拆解一个完整的I2C消息，包含**起始/停止条件、地址帧、读写位和应答(ACK/NACK)位**等所有关键元素。

---

### Ⅰ. I2C的物理层：开漏输出与上拉电阻

> [!info]
> I2C能够用两根线连接多个设备的关键，在于其独特的**开漏 (Open-Drain)**（或开集 Open-Collector）物理层设计。

> [!help] **工作机制**
> - **只能“拉低”，不能“推高”**: I2C设备内部的输出晶体管（如MOSFET）只能将总线**拉向低电平 (GND / 逻辑`0`)**。它无法主动输出高电平。
> - **上拉电阻的作用**: 因此，**必须**在SDA和SCL线上各连接一个**外部上拉电阻**到电源 (Vcc)。当总线上没有任何设备“拉低”线路时，这两个电阻会自动将线路的电平**“拉高”到高电平 (逻辑`1`)**，这也是总线的默认**空闲状态**。

> [!example] **一个生动的比喻：拔河比赛**
> > - **总线**: 想象成一根悬在半空的绳子。
> > - **上拉电阻**: 就像一个气球，总想把绳子**往天上拉**（高电平）。
> > - **I2C设备**: 就像一群站在地面上的人。每个人都只能**向下拉绳子**，但不能向上推。
> >
> > **“线与”逻辑**:
> > 绳子能保持在天上（高电平），**当且仅当所有的人都松开手**。只要**有任何一个人**用力向下拉，整根绳子都会被拉到地面（低电平）。

> [!check] **电路中的实现**
> > - **晶体管OFF (关)**: 设备“松开手”，线路由上拉电阻保持在**高电平 (HIGH / 1)**。
> > - **晶体管ON (开)**: 设备“向下拉”，将线路连接到GND，使线路变为**低电平 (LOW / 0)**。
> >
> >

---

### Ⅱ. I2C的协议层：一帧消息的完整结构

> [!tip]
> 一次完整的I2C通信由多个“帧”组成一条“消息”，并由独特的“起始”和“停止”条件来界定边界。



> [!note] **1. 起始条件 (Start Condition)**
> > - **时序**: 主设备(Master)在**SCL保持高电平**时，将**SDA从高电平跳变为低电平**。
> > - **作用**: 这是一个全局广播信号，通知总线上所有设备：“注意，通信即将开始！” 总线从此进入“繁忙”状态。

> [!note] **2. 停止条件 (Stop Condition)**
> > - **时序**: 主设备(Master)在**SCL保持高电平**时，将**SDA从低电平跳变为高电平**。
> > - **作用**: 标志着本次数据传输的结束，主设备释放总线，总线恢复到“空闲”状态。

> [!note] **3. 地址帧 (Address Frame)**
> > - **内容**: 紧跟在起始条件之后，主设备会发送一个7位或10位的序列，这是它想要通信的**从设备 (Slave) 的唯一地址**。
> > - **作用**: “点名”。总线上只有地址匹配的那个从设备，才会准备好后续的通信。

> [!note] **4. 读/写位 (Read/Write Bit)**
> > - **内容**: 紧跟在地址位之后的一位信号。
> > - **作用**: 告诉被选中的从设备，主设备接下来的意图。
> >   - **`0`**: 主设备要**写入 (Write)** 数据到从设备。
> >   - **`1`**: 主设备要**读取 (Read)** 从设备的数据。

> [!note] **5. 应答/非应答位 (ACK/NACK Bit)**
> > - **作用**: **这是保证I2C通信可靠性的核心机制**。
> > - **机制**: 每当发送方（无论是主设备还是从设备）成功发送完一个8位的字节（地址或数据）后，**接收方**会在第9个时钟周期，将**SDA线拉低**，以发送一个**ACK (Acknowledge)信号**，表示“我已成功收到，请继续”。
> > - **NACK**: 如果接收方没有拉低SDA线（线路因上拉电阻而保持高电平），则表示**NACK (Not Acknowledge)**，可能意味着设备正忙、数据出错或地址不匹配。


![[屏幕截图 2025-08-12 162555 1.png]]

![[屏幕截图 2025-08-12 162605 1.png]]

![[屏幕截图 2025-08-12 162617 1.png]]

![[屏幕截图 2025-08-12 162626 1.png]]

![[屏幕截图 2025-08-12 162634 1.png]]

![[屏幕截图 2025-08-12 162642 1.png]]

![[屏幕截图 2025-08-12 162652 1.png]]

![[屏幕截图 2025-08-12 162700 1.png]]

# 笔记：I2C通信协议 - 完整消息流程深度解析

> [!abstract] 核心纲要
> 本笔记旨在通过一个完整的时序图，以“剧本”的形式，深度剖析一次**I2C消息**从开始到结束的全过程。我们将重点关注：
> 1.  **起始 (Start)** 与 **停止 (Stop)** 条件的精确时序。
> 2.  **地址帧 (Address Frame)** 的广播与从设备的“监听”过程。
> 3.  **应答 (ACK/NACK)** 机制在主从设备之间的双向互动。
> 4.  **读操作**与**写操作**中，数据和应答信号的流向差异。
> 5.  **多主控仲裁 (Multi-Master Arbitration)** 机制。

---

### Ⅰ. I2C总线状态回顾

> [!info]
> 在任何通信发生之前，我们需要了解总线的两种基本状态。
> - **空闲状态 (Idle)**: **SDA** 和 **SCL** 两条线都由上拉电阻保持在**高电平**。此时总线是“自由的”，任何主设备都可以尝试发起通信。
> - **繁忙状态 (Busy)**: 当一个主设备发送**起始条件**后，总线即被占用，直到该主设备发送**停止条件**释放总线。

---

### Ⅱ. 一次完整I2C消息的“剧本” (A Play-by-Play)

> [!example]
> 下图展示了一次典型的I2C消息（包含地址帧、数据帧和各种控制信号）的完整时序。我们将按照时钟周期，一步步解析这个“剧本”。



> [!tip] **第1步：起始条件 (Start Condition) - “开场白”**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 主设备在 **SCL 保持高电平** 的前提下，将 **SDA 从高电平拉为低电平**。
> > - **作用**: 这是一个独特的、全局的信号，通知总线上所有设备：“注意，通信即将开始！” 主设备从此占有总线。

> [!tip] **第2步：发送地址帧 (Address Frame) - “点名” (时序图周期 1-8)**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 主设备开始驱动SCL产生时钟脉冲，并在每个脉冲期间，将**7位从设备地址**和**1位读/写控制位 (`R/W`)** 依次放到SDA线上。
> > - **作用**: 总线上**所有从设备**都会监听这个地址，并与自己的唯一地址进行比较。

> [!tip] **第3步：从设备应答 (ACK) - “到！” (时序图周期 9)**
> > - **执行者**: **地址匹配的从设备 (Slave)**。
> > - **时序**:
> >   1. 主设备在发送完第8位（R/W位）后，会**释放**SDA线。
> >   2. 那个地址匹配的从设备，则会**主动将SDA线拉低**，并保持一个时钟周期。
> > - **作用**: 这个由从设备发出的低电平，就是一个**应答信号 (Acknowledge, ACK)**。它告诉主设备：“我听到了，地址正确，我已准备好！” 主设备在检测到ACK后，才会继续下一步。
> > - **NACK**: 如果没有从设备应答，SDA线会保持高电平，主设备就知道通信对象不存在或无响应。

> [!tip] **第4步：发送/接收数据帧 (Data Frame) 与后续应答 (时序图周期 10-17, ...)**
> > - **执行者**: **取决于R/W位**。
> > - **时序**: 主设备继续产生时钟脉冲，一个或多个8位的数据字节在SDA线上进行传输。
> >
> > > [!check] **应答信号 (ACK) 的流向**
> > > **每传输完一个字节，接收方都需要发送一个ACK信号。**
> > > - 当主设备**写入 (Writing)** 数据时: **从设备**是接收方，因此**从设备**产生ACK信号。
> > > - 当主设备**读取 (Reading)** 数据时: **主设备**是接收方，因此**主设备**产生ACK信号。

> [!tip] **第5步：停止条件 (Stop Condition) - “再见”**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 在所有数据交换和应答完成后，主设备在 **SCL 保持高电平** 的前提下，将 **SDA 从低电平跳变为高电平**。
> > - **作用**: 标志着本次数据传输的全部结束，主设备**释放总线**，总线恢复到**空闲状态**。

---

### Ⅲ. I2C的高级特性：多主控仲裁

> [!question]
> I2C总线允许连接多个主设备。但如果两个主设备**同时**试图发起通信，会发生什么？

> [!help] **解决方案：仲裁 (Arbitration)**
> > I2C的**开漏 (Open-Drain)** 和 **上拉电阻** 物理层结构，为解决这个问题提供了一个无需额外硬件的、非常优雅的方案。
> >
> > **仲裁过程**:
> > 1. **发送前监听**: 任何一个主设备在发送一位数据（尤其是高电平`1`）之前，都会先**监听**一下SDA线的实际电平。
> > 2. **检测冲突**: 假设主设备A想发送 `1`（释放SDA线），但它却检测到SDA线**实际上是低电平**，这意味着有另一个主设备B正在发送 `0`（主动将SDA线拉低）。
> > 3. **失败者退出**: 检测到冲突的主设备A，会立刻意识到自己**“输掉了仲裁”**，它会立即**放弃**对总线的控制，并转入接收模式，等待总线再次变为空闲。
> > 4. **胜利者继续**: 而那个成功将总线拉低的主设备B，则完全没有察觉到任何冲突，它会继续完成它的数据传输。
>
> **结论**: 这个仲裁过程保证了在任何时刻，总线上都**只有一个主设备**在进行通信，避免了数据冲突。



![[屏幕截图 2025-08-12 162709 1.png]]

![[屏幕截图 2025-08-12 162717 1.png]]

![[屏幕截图 2025-08-12 162727 1.png]]

![[屏幕截图 2025-08-12 162735 1.png]]

![[屏幕截图 2025-08-12 162744 1.png]]

![[屏幕截图 2025-08-12 162753 1.png]]

![[屏幕截图 2025-08-12 162803 1.png]]

![[屏幕截图 2025-08-12 162816 1.png]]

# 笔记：I2C通信协议 - 完整消息流程深度解析

> [!abstract] 核心纲要
> 本笔记旨在通过一个完整的时序图，以“剧本”的形式，深度剖析一次**I2C消息**从开始到结束的全过程。我们将重点关注：
> 1.  **起始 (Start)** 与 **停止 (Stop)** 条件的精确时序。
> 2.  **地址帧 (Address Frame)** 的广播与从设备的“监听”过程。
> 3.  **应答 (ACK/NACK)** 机制在主从设备之间的双向互动。
> 4.  **读操作**与**写操作**中，数据和应答信号的流向差异。

---

### Ⅰ. I2C总线状态回顾

> [!info]
> 在任何通信发生之前，我们需要了解总线的两种基本状态。
> - **空闲状态 (Idle)**: **SDA** 和 **SCL** 两条线都由上拉电阻保持在**高电平**。此时总线是“自由的”，任何主设备都可以尝试发起通信。
> - **繁忙状态 (Busy)**: 当一个主设备发送**起始条件**后，总线即被占用，直到该主设备发送**停止条件**释放总线。

---

### Ⅱ. 一次完整I2C消息的“剧本” (A Play-by-Play)

> [!example]
> 下图展示了一次典型的I2C消息（包含地址帧、数据帧和各种控制信号）的完整时序。我们将按照时钟周期，一步步解析这个“剧本”。


> [!tip] **第1步：起始条件 (Start Condition) - “开场白”**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 主设备在 **SCL 保持高电平** 的前提下，将 **SDA 从高电平拉为低电平**。
> > - **作用**: 这是一个独特的、全局的信号，通知总线上所有设备：“注意，通信即将开始！” 主设备从此占有总线。

> [!tip] **第2步：发送地址帧 (Address Frame) - “点名” (时序图周期 1-8)**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 主设备开始驱动SCL产生时钟脉冲，并在每个脉冲期间，将**7位从设备地址**和**1位读/写控制位 (`R/W`)** 依次放到SDA线上。
> > - **作用**: 总线上**所有从设备**都会监听这个地址，并与自己的唯一地址进行比较。

> [!tip] **第3步：从设备应答 (ACK) - “到！” (时序图周期 9)**
> > - **执行者**: **地址匹配的从设备 (Slave)**。
> > - **时序**:
> >   1. 主设备在发送完第8位（R/W位）后，会**释放**SDA线。
> >   2. 那个地址匹配的从设备，则会**主动将SDA线拉低**，并保持一个时钟周期。
> > - **作用**: 这个由从设备发出的低电平，就是一个**应答信号 (Acknowledge, ACK)**。它告诉主设备：“我听到了，地址正确，我已准备好！” 主设备在检测到ACK后，才会继续下一步。
> > - **NACK**: 如果没有从设备应答，SDA线会保持高电平，主设备就知道通信对象不存在或无响应。

> [!tip] **第4步：发送/接收数据帧 (Data Frame) 与后续应答 (时序图周期 10-17, ...)**
> > - **执行者**: **取决于R/W位**。
> > - **时序**: 主设备继续产生时钟脉冲，一个或多个8位的数据字节在SDA线上进行传输。
> >
> > > [!check] **应答信号 (ACK) 的流向**
> > > **每传输完一个字节，接收方都需要发送一个ACK信号。**
> > > - 当主设备**写入 (Writing)** 数据时: **从设备**是接收方，因此**从设备**产生ACK信号。
> > > - 当主设备**读取 (Reading)** 数据时: **主设备**是接收方，因此**主设备**产生ACK信号。

> [!tip] **第5步：停止条件 (Stop Condition) - “再见”**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 在所有数据交换和应答完成后，主设备在 **SCL 保持高电平** 的前提下，将 **SDA 从低电平跳变为高电平**。
> > - **作用**: 标志着本次数据传输的全部结束，主设备**释放总线**，总线恢复到**空闲状态**。

![[屏幕截图 2025-08-12 162831 1.png]]

![[屏幕截图 2025-08-12 162839 1.png]]

![[屏幕截图 2025-08-12 162848 1.png]]

![[屏幕截图 2025-08-12 162857 1.png]]

![[屏幕截图 2025-08-12 162905 1.png]]

![[屏幕截图 2025-08-12 162914 1.png]]

![[屏幕截图 2025-08-12 162923 1.png]]

![[屏幕截图 2025-08-12 162932 1.png]]

# 笔记：I2C通信协议 - 完整消息流程深度解析

> [!abstract] 核心纲要
> 本笔记旨在通过一个完整的时序图，以“剧本”的形式，深度剖析一次**I2C消息**从开始到结束的全过程。我们将重点关注：
> 1.  **起始 (Start)** 与 **停止 (Stop)** 条件的精确时序。
> 2.  **地址帧 (Address Frame)** 的广播与从设备的“监听”过程。
> 3.  **应答 (ACK/NACK)** 机制在主从设备之间的双向互动。
> 4.  **读操作**与**写操作**中，数据和应答信号的流向差异。

---

### Ⅰ. I2C总线状态回顾

> [!info]
> 在任何通信发生之前，我们需要了解总线的两种基本状态。
> - **空闲状态 (Idle)**: **SDA** 和 **SCL** 两条线都由上拉电阻保持在**高电平**。此时总线是“自由的”，任何主设备都可以尝试发起通信。
> - **繁忙状态 (Busy)**: 当一个主设备发送**起始条件**后，总线即被占用，直到该主设备发送**停止条件**释放总线。

---

### Ⅱ. 一次完整I2C消息的“剧本” (A Play-by-Play)

> [!example]
> 下图展示了一次典型的I2C消息（包含地址帧、数据帧和各种控制信号）的完整时序。我们将按照时钟周期，一步步解析这个“剧本”。



> [!tip] **第1步：起始条件 (Start Condition) - “开场白”**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 主设备在 **SCL 保持高电平** 的前提下，将 **SDA 从高电平拉为低电平**。
> > - **作用**: 这是一个独特的、全局的信号，通知总线上所有设备：“注意，通信即将开始！” 主设备从此占有总线。

> [!tip] **第2步：发送地址帧 (Address Frame) - “点名” (时序图周期 1-8)**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 主设备开始驱动SCL产生时钟脉冲，并在每个脉冲期间，将**7位从设备地址**和**1位读/写控制位 (`R/W`)** 依次放到SDA线上。
> > - **作用**: 总线上**所有从设备**都会监听这个地址，并与自己的唯一地址进行比较。

> [!tip] **第3步：从设备应答 (ACK) - “到！” (时序图周期 9)**
> > - **执行者**: **地址匹配的从设备 (Slave)**。
> > - **时序**:
> >   1. 主设备在发送完第8位（R/W位）后，会**释放**SDA线。
> >   2. 那个地址匹配的从设备，则会**主动将SDA线拉低**，并保持一个时钟周期。
> > - **作用**: 这个由从设备发出的低电平，就是一个**应答信号 (Acknowledge, ACK)**。它告诉主设备：“我听到了，地址正确，我已准备好！” 主设备在检测到ACK后，才会继续下一步。
> > - **NACK**: 如果没有从设备应答，SDA线会保持高电平，主设备就知道通信对象不存在或无响应。

> [!tip] **第4步：发送/接收数据帧 (Data Frame) 与后续应答 (时序图周期 10-17, ...)**
> > - **执行者**: **取决于R/W位**。
> > - **时序**: 主设备继续产生时钟脉冲，一个或多个8位的数据字节在SDA线上进行传输。
> >
> > > [!check] **应答信号 (ACK) 的流向**
> > > **每传输完一个字节，接收方都需要发送一个ACK信号。**
> > > - 当主设备**写入 (Writing)** 数据时: **从设备**是接收方，因此**从设备**产生ACK信号。
> > > - 当主设备**读取 (Reading)** 数据时: **主设备**是接收方，因此**主设备**产生ACK信号。

> [!tip] **第5步：停止条件 (Stop Condition) - “再见”**
> > - **执行者**: **主设备 (Master)**。
> > - **时序**: 在所有数据交换和应答完成后，主设备在 **SCL 保持高电平** 的前提下，将 **SDA 从低电平跳变为高电平**。
> > - **作用**: 标志着本次数据传输的全部结束，主设备**释放总线**，总线恢复到**空闲状态**。


![[屏幕截图 2025-08-12 162941 1.png]]

![[屏幕截图 2025-08-12 162950 1.png]]

![[屏幕截图 2025-08-12 162959 1.png]]

![[屏幕截图 2025-08-12 163007 1.png]]

![[屏幕截图 2025-08-12 163016 1.png]]

![[屏幕截图 2025-08-12 163027 1.png]]

![[屏幕截图 2025-08-12 163037 1.png]]

![[屏幕截图 2025-08-12 163046 1.png]]
# 笔记：I2C高级特性与协议选择 (Advanced I2C & Protocol Selection)

> [!abstract] 核心纲要
> 本笔记旨在深入剖析**I2C (集成电路互联总线)** 的高级工作流程与特性。我们将重点关注：
> 1.  **读/写操作流程**: 详细对比**主设备写入**与**主设备读取**两种通信场景下的详细步骤和ACK/NACK信号流向。
> 2.  **高级协议特性**: 解析**时钟伸展 (Clock Stretching)** 和**多主控仲裁 (Multi-Master Arbitration)** 的工作原理。
> 3.  **协议选择**: 通过一个清晰的对比表，总结在不同设计需求下，如何在**I2C**和**SPI**之间做出正确的选择。

---

### Ⅰ. I2C的读/写操作流程

> [!info]
> I2C的通信“剧本”根据数据流向的不同（主设备写 vs. 主设备读）而略有差异，尤其是在**应答(ACK)信号的发送方**上。

> [!success] **1. 主设备写入从设备 (Writing to a Slave)**
> > 这是最常见的操作，例如MCU向一个传感器写入配置寄存器。
> >
> > **流程**:
> > 1. **Master** 发送**起始条件 (S)**。
> > 2. **Master** 发送**从设备地址** + **写信号 (W, 即R/W=0)**。
> > 3. **Slave** 回复一个**ACK**，表示“地址正确，我准备好接收了”。
> > 4. **Master** 发送一个**数据字节**。
> > 5. **Slave** 再次回复一个**ACK**，表示“数据已成功收到”。
> >    *(步骤4和5可以重复多次，以发送多个数据字节)*
> > 6. **Master** 发送**停止条件 (P)**，结束通信。
> >
> > 

> [!tip] **2. 主设备读取从设备 (Reading from a Slave)**
> > 例如MCU从一个温度传感器读取测量数据。
> >
> > **流程**:
> > 1. **Master** 发送**起始条件 (S)**。
> > 2. **Master** 发送**从设备地址** + **读信号 (R, 即R/W=1)**。
> > 3. **Slave** 回复一个**ACK**，表示“地址正确，我准备好发送数据了”。
> > 4. **Slave** 发送一个**数据字节**给Master。
> > 5. **Master** 回复一个**ACK**，表示“数据已成功收到，请继续发送下一个”（如果还想读的话）。
> >    > [!warning] **关键区别**: 如果Master**不希望**再接收更多数据，它会发送一个**NACK (非应答)**信号，告诉Slave“这是最后一个字节了，请停止发送”。
> > 6. **Master** 发送**停止条件 (P)**，结束通信。

---

### Ⅱ. I2C的高级协议特性

> [!help]
> I2C协议内置了一些精巧的机制，以处理更复杂的通信场景。

> [!check] **1. 时钟伸展 (Clock Stretching)**
> > - **目的**: 一种**流量控制 (Flow Control)** 机制。
> > - **机制**: 如果一个被寻址的**从设备**暂时很忙（例如，正在进行内部测量，来不及准备好要发送的数据），它可以**主动将SCL时钟线拉低并保持**。
> > - **效果**: 主设备会检测到时钟线被“卡住”，并**暂停**后续的时钟脉冲，**耐心等待**，直到从设备完成工作并释放SCL线后，通信才会继续。
> > - **比喻**: 就像从设备对主设备说：“**等一下，我还没准备好！**”
> >
> > 

> [!check] **2. 多主控仲裁 (Multi-Master Arbitration)**
> > - **目的**: 解决**两个或多个主设备**同时试图发起通信的**冲突**。
> > - **机制**: 利用I2C总线“**线与**”的物理特性（任何设备拉低，整条线都为低）。
> > - **流程**:
> >   1. **发送前监听**: 任何一个主设备在发送一位数据（尤其是高电平`1`）之前，都会先**监听**一下SDA线的实际电平。
> >   2. **检测冲突**: 假设主设备A想发送 `1`（释放SDA线），但它却检测到SDA线**实际上是低电平**，这意味着有另一个主设备B正在发送 `0`。
> >   3. **失败者退出**: 检测到冲突的主设备A，会立刻意识到自己**“输掉了仲裁”**，它会立即**放弃**对总线的控制，并转入接收模式。
> >   4. **胜利者继续**: 而那个成功将总线拉低的主设备B，则完全没有察觉到任何冲突，它会继续完成它的数据传输。
> >
> > **结论**: 这个仲裁过程保证了在任何时刻，总线上都**只有一个主设备**在进行通信，避免了数据冲突。

---

### Ⅲ. 协议选择：SPI vs. I2C

> [!summary]
> 在设计一个系统时，如何在这两种主流的同步串行协议之间做出选择？

| 目的 (Purpose) | I2C | SPI |
| :--- | :--- | :--- |
| **布线简洁性** | **极简**: 所有设备仅需**2根线** (SDA, SCL) | **复杂**: 需要**4根线 + 每个从设备1根额外的SS线** |
| **可扩展性** | **容易**: 在同一总线上连接大量设备非常方便 | 随着从设备增多，SS线的需求使其变得复杂 |
| **速度** | 相对较慢 (Slower) | 通常**更快 (Faster)**，数据速率更高 |
| **最佳适用场景** | 连接**大量中低速设备**的简约布局 | 与**少量需要高速通信**的设备进行通信 |

![[屏幕截图 2025-08-12 164708.png]]

![[屏幕截图 2025-08-12 164715.png]]

![[屏幕截图 2025-08-12 164723.png]]

![[屏幕截图 2025-08-12 164730.png]]

![[屏幕截图 2025-08-12 164746.png]]

![[屏幕截图 2025-08-12 164757.png]]

![[屏幕截图 2025-08-12 164810.png]]

![[屏幕截图 2025-08-12 164821.png]]

# 笔记：嵌入式系统任务管理 - 轮询 (Polling) vs. 中断 (Interrupts)

> [!abstract] 核心纲要
> 本笔记旨在深入剖析嵌入式系统中管理多个任务的两种核心机制：**轮询 (Polling)** 和 **中断 (Interrupts)**。我们将重点关注：
> 1.  **任务的分类**: 理解**时间触发 (Time-Triggered)** 与**事件触发 (Event-Triggered)** 任务的区别。
> 2.  **轮询 (Polling)**: 解析其工作原理，并分析其**效率低下**和**无法区分优先级**的致命缺陷。
> 3.  **中断 (Interrupts)**: 阐明其作为一种**高效、高响应**事件处理机制的优势。
> 4.  **全面对比**: 通过一个清晰的对比表和生动的比喻，总结在何种场景下应该选择哪种机制。

---

### Ⅰ. 嵌入式系统的挑战：多任务处理 (Multi-tasking)

> [!info]
> 几乎所有的嵌入式系统都需要在同一时间处理**多项不同的活动**，我们称之为**任务 (Tasks)**。如何高效、可靠地调度这些任务，是嵌入式编程的核心挑战。

> [!example] **任务的两种基本类型**
> 1. **时间触发 (Time-Triggered)**:
>    - **特点**: **周期性地**、在预先确定的时间点发生。
>    - **例子**: 恒温控制器**每分钟**测量一次温度。
> 2. **事件触发 (Event-Triggered)**:
>    - **特点**: 在某个**不可预测**的外部事件发生时才被触发。
>    - **例子**: 用户**随时可能**按下遥控器上的按钮；**突然发生**的断电。

---

### Ⅱ. 简单的解决方案：轮询 (Polling) - “你好，需要服务吗？”

> [!help]
> **定义**: **轮询**是CPU在一个**无限循环**中，**持续地、挨个地**检查每一个设备的状态，看它是否需要CPU的服务。

> [!tip] **一个生动的比喻：一个过分积极的服务员**
> > 想象一个服务员，他不断地在几张桌子（设备）之间来回奔跑，挨个询问：“你好，需要加水吗？”、“你好，需要点餐吗？”、“你好，需要结账吗？”…… 不断重复。

> [!check] **轮询的挑战 (Challenges)**
> 1. **CPU效率低下 (Inefficient)**:
>    - 服务员（CPU）的绝大部分时间都花在了**无效的询问**上，因为大多数时候客人（设备）并不需要服务。CPU被牢牢地拴在检查循环中，**无法去处理其他更有价值的任务**。
> 2. **无法区分优先级 (Treats all inputs as equal)**:
>    - 在服务员的眼中，客人想“加水”的请求和厨房通知“菜做好了，快来取”的紧急事件，**优先级是相同的**。紧急的事件必须**排队等待**服务员轮到它时才能被处理，这在实时系统中可能是致命的。

---

### Ⅲ. 更优的解决方案：中断 (Interrupts) - “叮咚，我需要服务！”

> [!success]
> **定义**: **中断**是一种硬件机制，它允许外部设备在需要服务时，**主动地向CPU发送一个信号**，来“打断”CPU当前正在做的事情，请求立即处理。

> [!tip] **一个生动的比喻：带呼叫铃的服务员**
> > 想象一个更聪明的服务员。他平时可以专心做自己的事（比如擦杯子）。每张桌子上都有一个**呼叫铃**。
> >
> > - **高效**: 只有当客人（设备）**确实需要服务时**，他才会按下呼叫铃（**产生中断**）。服务员听到铃声，才会放下手中的活，前去服务。CPU**只在事件发生时才被通知**，效率极高。
> > - **可设优先级**: 不同的呼叫铃可以有不同的铃声。厨房的紧急呼叫铃（**高优先级中断**）一响，服务员会立刻放下为客人加水（**低优先级任务**）的工作，优先处理。系统可以**区分任务的紧急程度**。

---

### Ⅳ. 全面对比：Polling vs. Interrupt

> [!summary]

| 特性 (Feature) | 中断 (Interrupt) | 轮询 (Polling) |
| :--- | :--- | :--- |
| **工作方式** | CPU**仅在事件发生时**被通知 | CPU**重复地检查**事件是否已发生 |
| **CPU效率** | **高效 (Efficient)** - CPU可执行其他任务 | **低效 (Inefficient)** - CPU浪费时间在检查上 |
| **适用场景** | 事件发生时间**不可预测**或**很关键**时 | 事件发生**频繁**或**有时间规律**时 |
| **优先级** | **可以设置**关键任务的优先级 | **平等对待**所有任务，无法区分紧急程度 |
| **典型例子** | **按键按下**、传感器警报 | 在循环中快速读取传感器数据 |

![[屏幕截图 2025-08-12 164832.png]]

![[屏幕截图 2025-08-12 164845.png]]

![[屏幕截图 2025-08-12 164859.png]]

![[屏幕截图 2025-08-12 164915.png]]

![[屏幕截图 2025-08-12 164926.png]]

![[屏幕截图 2025-08-12 164937.png]]

![[屏幕截图 2025-08-12 164947.png]]

![[屏幕截图 2025-08-12 165001.png]]

# 笔记：嵌入式系统核心机制 - 中断 (Interrupts)

> [!abstract] 核心纲要
> 本笔记旨在深入剖析嵌入式系统中比**轮询 (Polling)** 更高效的事件处理机制——**中断 (Interrupts)**。我们将重点关注：
> 1.  **中断是什么**: 理解其作为一种“暂停-处理-恢复”机制的核心思想。
> 2.  **中断的类型**: 区分由外部设备触发的**硬件中断**和由程序自身触发的**软件中断**。
> 3.  **中断的执行流程**: 详细拆解微控制器响应一次中断的**五个关键步骤**，理解**中断服务程序(ISR)** 和 **中断向量表**的作用。
> 4.  **Mbed中的中断编程**: 了解如何使用`InterruptIn` API来处理外部中断。

---

### Ⅰ. 中断是什么？- “门铃”式的事件处理

> [!info]
> **定义**: **中断 (Interrupt)** 是一个由硬件或软件发给处理器的信号，指示有某个**需要立即关注**的事件已经发生。

> [!success] **核心机制：“暂停-处理-恢复”**
> > 中断允许一个正在运行的程序被**暂停 (suspend)**，以便CPU能够去处理一个特定的突发事件。一旦该事件处理完毕，原始的程序可以**从它被暂停的地方继续 (continue)** 执行。

> [!example] **一个生动的比喻：专心读书 vs. 有人按门铃**
> > - **轮询 (Polling)**: 就像你每隔几秒钟就跑去门口的猫眼看一次，确认有没有访客。这非常**低效**，让你无法专心读书。
> > - **中断 (Interrupt)**: 你可以专心读书（执行主程序）。当有访客（外部事件）到来时，他会**按门铃（产生中断信号）**。你听到铃声，**暂停**读书，去开门处理访客事务（**执行中断服务程序**），处理完毕后，再回到书桌前，从你之前做的书签处**继续**阅读。这非常**高效**。

---

### Ⅱ. 中断的两种类型

> [!tip]
> 中断可以根据其来源，分为外部（硬件）和内部（软件）两种。

> [!check] **1. 硬件中断 (External/Hardware Interrupt)**
> > - **触发源**: 由一个**外部事件**引起。
> > - **定义**: 一个外部设备（如传感器、按键）发送给处理器的**电子警报信号**。
> > - **例子**:
> >   - **按下按钮**连接到微控制器。
> >   - **运动传感器**检测到移动。
> >   - **键盘**被敲击或**鼠标**被移动。

> [!danger] **2. 软件中断 (Internal/Software Interrupt)**
> > - **触发源**: 由**软件指令的执行**本身引起。
> > - **定义**: 通常由一个**异常情况**或一个特殊的**中断指令**导致。
> > - **例子**:
> >   - **除零异常 (Divide-by-zero exception)**: 当CPU的算术逻辑单元（ALU）执行一条除以零的命令时，会触发一个内部中断，以处理这个数学错误（例如，显示一个错误信息或中止计算）。

---

### Ⅲ. 中断的执行流程：一步步解析

> [!help]
> 当一个中断发生时，微控制器会严格地按照以下五个步骤来执行。



1.  **暂停当前任务并保存“书签” (Halt and Save Context)**
    -   微控制器会**暂停**当前正在执行的任务。
    -   它会将**下一条即将执行的指令的地址**（存放在**程序计数器PC**中）**保存**到一个叫做**“栈”(Stack)** 的特殊内存区域。这就像在书中夹一个书签，记住你读到了哪里。

2.  **处理中断优先级 (Prioritize)**
    -   微控制器会执行**优先级更高**的中断，并暂时阻止（屏蔽）比它优先级低的其他中断。

3.  **查找“服务手册”地址 (Jump to Vector Table)**
    -   CPU会跳转到一个固定的内存地址，这个地址存放着**中断向量表 (Interrupt Vector Table)**。
    -   这个“向量表”就像一本“**服务手册的目录**”，它记录了每一种中断所对应的处理程序的**入口地址**。

4.  **执行中断服务程序 (Execute ISR)**
    -   微控制器从向量表中**读取**到对应的处理程序地址，然后**跳转**到该地址，开始执行**中断服务程序 (Interrupt Service Routine, ISR)**。
    -   ISR就是一段专门为处理该特定中断而编写的代码。

5.  **返回并恢复任务 (Return and Resume)**
    -   当ISR执行完毕后，微控制器会从**“栈”**中**取出**之前保存的“书签”（PC地址）。
    -   将这个地址放回程序计数器PC，**主程序**就会从它当初被打断的地方，**无缝地继续执行下去**。

---

### Ⅳ. Mbed中的中断编程 API

> [!cite]
> 在Mbed等高级平台中，我们可以用简单的API来配置和使用中断。

- **`InterruptIn`**: 创建一个中断输入对象，并将其连接到一个指定的MCU引脚。
- **`.rise(&function)`**: **附加**一个函数，当在该引脚上检测到**上升沿 (LOW -> HIGH)** 时，自动调用这个函数。
- **`.fall(&function)`**: **附加**一个函数，当在该引脚上检测到**下降沿 (HIGH -> LOW)** 时，自动调用这个函数。

![[屏幕截图 2025-08-12 165013.png]]

![[屏幕截图 2025-08-12 165021.png]]

![[屏幕截图 2025-08-12 165032.png]]

![[屏幕截图 2025-08-12 165044.png]]

![[屏幕截图 2025-08-12 165053.png]]

![[屏幕截图 2025-08-12 165106.png]]

![[屏幕截图 2025-08-12 165118.png]]

![[屏幕截图 2025-08-12 165139.png]]