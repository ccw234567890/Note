![[Pasted image 20250811145633.png]]

# 笔记：多路复用器 (Multiplexer, MUX) - 数据的“十字路口”

> [!abstract] 核心纲要
> 本笔记旨在深入剖析**多路复用器 (MUX)** 的核心概念。我们将重点关注：
> 1.  **MUX的直观理解**: 它就像一个受交通信号灯控制的、多条路汇入一条路的“十字路口”。
> 2.  **MUX的正式定义**: 它是一个根据“选择信号”从多个输入中选择一个，并将其连接到单一输出的组合逻辑电路。
> 3.  **MUX的工作原理**: 通过一个4选1 MUX的具体例子，解析其输入、输出和选择线之间的关系。

---

### Ⅰ. 直观理解：一个受控制的数据选择器

> [!example] **图中生动的比喻：多车道汇流**
> > 我们可以将MUX的工作过程想象成一个有多条车道（**Inputs**）准备汇入一条主干道（**Output**）的场景。
> > - **多条车道 (Inputs)**: `I₀`, `I₁`, `I₂`, `I₃`，每一条车道上都有等待通行的汽车（**二进制数据**）。
> > - **一条主干道 (Output)**: `Y`，最终只有一辆车能通过。
> > - **交通信号灯/管理员 (Selection Lines)**: `S₁`, `S₀`，它们是**控制中心**。通过发出不同的指令（二进制信号，如 `00`, `01`, `10`, `11`），来决定**哪一条车道**的“STOP”标志会抬起，允许该车道的汽车汇入主干道。

**结论**: MUX的本质就是一个**数据选择器**。它的核心功能是**“多选一”**。

---

### Ⅱ. MUX的正式定义与组件

> [!info]
> **定义**: 多路复用器（MUX）是一个组合逻辑电路，它从多个输入线中选择一个，并将该输入线上的二进制信息引导至一个单一的输出线。

> [!check] **核心组件**
> - **数据输入线 (Input Lines)**: 提供多个数据源以供选择。
> - **数据输出线 (Output Line)**: 只有一个，用于传输被选中的数据。
> - **选择线 (Selection Lines)**: 控制信号输入端。它们输入的二进制值，就像一个**“地址”**，精确地指定了哪条输入线将被连接到输出线。

> [!tip] **“2ⁿ to n” 规则**
> > MUX的输入线数量和选择线数量之间存在一个固定的数学关系：
> >
> > **`n` 条选择线可以控制 `2ⁿ` 条输入线。**
> >
> > - **1条**选择线 (`n=1`) 可以有两种状态 (`0`, `1`)，因此可以控制一个 **2选1** 的MUX。
> > - **2条**选择线 (`n=2`) 可以有四种状态 (`00`, `01`, `10`, `11`)，因此可以控制一个 **4选1** 的MUX（如图中所示）。
> > - **3条**选择线 (`n=3`) 可以有八种状态 (`000` 到 `111`)，因此可以控制一个 **8选1** 的MUX。

---

### Ⅲ. 实例解析：4选1 MUX的工作原理

> [!help]
> 图中的黄色方框（逻辑符号）和其旁边的真值表，完美地展示了一个4选1 MUX的工作方式。

#### **逻辑符号**
- **4个输入**: `I₀`, `I₁`, `I₂`, `I₃`
- **2个选择线**: `S₁`, `S₀`
- **1个输出**: `Y`

#### **真值表 (Truth Table) 解读**
真值表清晰地描述了选择线 (`S₁`, `S₀`) 的不同状态如何决定输出 `Y` 的值。

| S₁ | S₀ | 二进制值 | 输出 Y | 解释 |
|:---:|:---:|:---|:---:|:---|
| **0** | **0** | `00` (等于0) | **I₀** | 当选择信号为`00`时，**第0条**输入线`I₀`被选中，其数据被传送到输出`Y`。 |
| **0** | **1** | `01` (等于1) | **I₁** | 当选择信号为`01`时，**第1条**输入线`I₁`被选中，其数据被传送到输出`Y`。 |
| **1** | **0** | `10` (等于2) | **I₂** | 当选择信号为`10`时，**第2条**输入线`I₂`被选中，其数据被传送到输出`Y`。 |
| **1-** | **1** | `11` (等于3) | **I₃** | 当选择信号为`11`时，**第3条**输入线`I₃`被选中，其数据被传送到输出`Y`。 |

**总结**: MUX通过**选择线**上的二进制**地址码**，实现了对多路数据源的精确选择，是构建CPU、内存控制器以及各种数字通信系统的基础逻辑单元。

![[Pasted image 20250811151139.png]]
![[Pasted image 20250811151230.png]]

# 笔记：多路复用器 (Multiplexer, MUX) - 数据的“十字路口”

> [!abstract] 核心纲要
> 本笔记旨在深入剖析**多路复用器 (MUX)** 的核心概念。我们将重点关注：
> 1.  **MUX的直观理解**: 它就像一个受交通信号灯控制的、多条路汇入一条路的“十字路口”。
> 2.  **MUX的正式定义**: 它是一个根据“选择信号”从多个输入中选择一个，并将其连接到单一输出的组合逻辑电路。
> 3.  **MUX的工作原理**: 通过一个4选1 MUX的具体例子，解析其输入、输出和选择线之间的关系。

---

### Ⅰ. 直观理解：一个受控制的数据选择器

> [!example] **图中生动的比喻：多车道汇流**
> > 我们可以将MUX的工作过程想象成一个有多条车道（**Inputs**）准备汇入一条主干道（**Output**）的场景。
> > - **多条车道 (Inputs)**: `I₀`, `I₁`, `I₂`, `I₃`，每一条车道上都有等待通行的汽车（**二进制数据**）。
> > - **一条主干道 (Output)**: `Y`，最终只有一辆车能通过。
> > - **交通信号灯/管理员 (Selection Lines)**: `S₁`, `S₀`，它们是**控制中心**。通过发出不同的指令（二进制信号，如 `00`, `01`, `10`, `11`），来决定**哪一条车道**的“STOP”标志会抬起，允许该车道的汽车汇入主干道。

**结论**: MUX的本质就是一个**数据选择器**。它的核心功能是**“多选一”**。

---

### Ⅱ. MUX的正式定义与组件

> [!info]
> **定义**: 多路复用器（MUX）是一个组合逻辑电路，它从多个输入线中选择一个，并将该输入线上的二进制信息引导至一个单一的输出线。

> [!check] **核心组件**
> - **数据输入线 (Input Lines)**: 提供多个数据源以供选择。
> - **数据输出线 (Output Line)**: 只有一个，用于传输被选中的数据。
> - **选择线 (Selection Lines)**: 控制信号输入端。它们输入的二进制值，就像一个**“地址”**，精确地指定了哪条输入线将被连接到输出线。

> [!tip] **“2ⁿ to n” 规则**
> > MUX的输入线数量和选择线数量之间存在一个固定的数学关系：
> >
> > **`n` 条选择线可以控制 `2ⁿ` 条输入线。**
> >
> > - **1条**选择线 (`n=1`) 可以有两种状态 (`0`, `1`)，因此可以控制一个 **2选1** 的MUX。
> > - **2条**选择线 (`n=2`) 可以有四种状态 (`00`, `01`, `10`, `11`)，因此可以控制一个 **4选1** 的MUX（如图中所示）。
> > - **3条**选择线 (`n=3`) 可以有八种状态 (`000` 到 `111`)，因此可以控制一个 **8选1** 的MUX。

---

### Ⅲ. 实例解析：4选1 MUX的工作原理

> [!help]
> 图中的黄色方框（逻辑符号）和其旁边的真值表，完美地展示了一个4选1 MUX的工作方式。

#### **逻辑符号**
- **4个输入**: `I₀`, `I₁`, `I₂`, `I₃`
- **2个选择线**: `S₁`, `S₀`
- **1个输出**: `Y`

#### **真值表 (Truth Table) 解读**
真值表清晰地描述了选择线 (`S₁`, `S₀`) 的不同状态如何决定输出 `Y` 的值。

| S₁ | S₀ | 二进制值 | 输出 Y | 解释 |
|:---:|:---:|:---|:---:|:---|
| **0** | **0** | `00` (等于0) | **I₀** | 当选择信号为`00`时，**第0条**输入线`I₀`被选中，其数据被传送到输出`Y`。 |
| **0** | **1** | `01` (等于1) | **I₁** | 当选择信号为`01`时，**第1条**输入线`I₁`被选中，其数据被传送到输出`Y`。 |
| **1** | **0** | `10` (等于2) | **I₂** | 当选择信号为`10`时，**第2条**输入线`I₂`被选中，其数据被传送到输出`Y`。 |
| **1-** | **1** | `11` (等于3) | **I₃** | 当选择信号为`11`时，**第3条**输入线`I₃`被选中，其数据被传送到输出`Y`。 |

**总结**: MUX通过**选择线**上的二进制**地址码**，实现了对多路数据源的精确选择，是构建CPU、内存控制器以及各种数字通信系统的基础逻辑单元。

![[Pasted image 20250811152232.png]]

# 笔记：微控制器 (µC) 内部结构全解析

> [!abstract] 核心思想：一个高度集成的“专用迷你电脑”
> 这张图展示的是一个典型的**微控制器 (Microcontroller)** 的内部结构。它的核心特点是**高度集成化**：它不仅仅是一颗CPU，而是将**CPU、内存、以及各种各样的外设接口**全部集成在了**同一块芯片**上，构成了一个完整的、可以独立工作的微型计算机系统。

---

### Ⅰ. 中央核心 (The Core)

> [!info] **CPU (中央处理器)**
> > - **角色**: **大脑**。
> > - **功能**: 负责执行从内存中读取的程序指令，进行算术和逻辑运算，并控制芯片上所有其他模块的协调工作。它是整个微控制器的指挥中心。

---

### Ⅱ. 内存系统 (The Memory System)

> [!tip] 微控制器通常包含多种不同类型的内存，以满足不同需求。图中红框内突出了这一点。

> [!check] **RAM (随机存取存储器)**
> > - **角色**: **临时工作台 / 草稿纸**。
> > - **功能**: 用于存放程序运行时需要**临时读写**的变量和数据。
> > - **特点**: **易失性 (Volatile)**，意味着一旦断电，其中存储的所有数据都会丢失。

> [!check] **ROM / Flash / EEPROM (非易失性存储器)**
> > - **角色**: **长期档案馆 / 说明书**。
> > - **功能**: 用于存放**程序代码 (Code)** 和一些需要**永久保存**的配置数据。
> > - **特点**: **非易失性 (Non-Volatile)**，断电后数据**不会**丢失。
> >   - **ROM (只读存储器)**: 传统意义上的只读内存，出厂时就被写入，无法修改。
> >   - **Flash (闪存)**: 现代微控制器中最常用的程序存储器。它可以被**电信号**多次擦除和重写，使得**固件更新**成为可能。
> >   - **EEPROM**: 一种特殊的可擦写存储器，通常容量较小，用于保存用户设置、校准参数等需要频繁更新且掉电不丢失的数据。

---

### Ⅲ. 与外部世界的接口 (Interfaces to the Outside World)

> [!example]
> 这些模块是微控制器的“感官”和“发声器官”，负责与芯片外部进行交互。

> [!success] **I/O 端口 (I/O Ports A, B, ...)**
> > - **角色**: **手和脚**。
> > - **功能**: 通用的数字输入/输出引脚，是微控制器与外部世界最直接的连接方式。可以用来读取按键状态（输入），也可以用来点亮LED灯、控制继电器（输出）。

> [!success] **ADC (模数转换器) / DAC (数模转换器)**
> > - **角色**: **翻译官**。
> > - **ADC (Analog-to-Digital Converter)**: 将来自传感器的连续**模拟信号**（如温度、光强、声音）转换成CPU能理解的**数字值**。
> > - **DAC (Digital-to-Analog Converter)**: 将CPU产生的**数字值**转换成**模拟信号**，用于控制需要连续电压的设备（如驱动扬声器、控制电机精确速度）。

> [!success] **串行接口 (Serial Interface)**
> > - **角色**: **电话 / 电报机**。
> > - **功能**: 用于微控制器与其他芯片或设备进行**串行通信**（一次传输一位数据）。常见的类型有 **UART, SPI, I2C** 等，用于连接蓝牙模块、显示屏、其他微控制器等。

---

### Ⅳ. 控制与支持模块 (Control & Support Modules)

> [!help]
> 这些模块保证了微控制器能够稳定、精确地运行。

> [!time] **时钟生成电路 (Clock Generation Circuit)**
> > - **角色**: **心脏起搏器**。
> > - **功能**: 产生稳定、精确的时钟信号，为整个芯片提供统一的“心跳节拍”。CPU的每一个动作都与这个时钟信号同步，决定了微控制器的运行速度。

> [!note] **定时器/计数器 (Timers/Counters)**
> > - **角色**: **秒表和计数器**。
> > - **功能**: 可以在不占用CPU资源的情况下，独立进行精确的时间延迟、生成PWM波（用于控制电机转速或灯光亮度），或对外部脉冲信号进行计数。

> [!info] **中断控制器 (Interrupt Control)**
> > - **角色**: **紧急事件处理中心**。
> > - **功能**: 允许外部事件（如一个按键被按下）“打断”CPU正在执行的主程序，让CPU立即去处理这个更紧急的“中断”任务，处理完毕后再返回原任务。这极大地提高了系统的响应速度和效率。

> [!danger] **看门狗定时器 (Watchdog Timer)**
> > - **角色**: **安全监控员**。
> > - **功能**: 一个独立的定时器，程序需要在正常运行时周期性地“喂狗”（重置它）。如果程序因意外“死机”或陷入死循环，就无法“喂狗”，看门狗定时器会超时并强制**重启**整个微控制器，从而保证系统在无人看管的情况下也能从故障中自动恢复。

> [!power] **电源管理 (Power Management)**
> > - **角色**: **能量管家**。
> > - **功能**: 控制芯片的供电和功耗，支持多种工作模式（如运行模式、休眠模式），对于电池供电的低功耗应用至关重要。

![[Pasted image 20250811152422.png]]

# 笔记：计算机内存基础 (Memory Fundamentals)

> [!abstract] 核心纲要
> 本笔记旨在深入剖析计算机内存的核心概念。我们将重点关注：
> 1.  **内存的定义与作用**：它在计算机中扮演的角色。
> 2.  **地址 (Address) vs. 数据 (Data)**：理解内存中“位置”与“内容”的关键区别。
> 3.  **内存系统的权衡**: 在设计内存时，速度、成本、功耗和容量之间的关系。
> 4.  **具体实例**: 以mbed平台为例，理解32位地址和数据的含义。

---

### Ⅰ. 内存的定义与作用

> [!info]
> **定义**: 内存是计算机中用于存放需要被“记住”的信息的物理组件。这些被记住的信息统称为**数据 (Data)**。

> [!check] **基本操作**
> 内存中的数据可以被处理器进行三种基本操作：
> - **存储 (Store)**: 将新数据写入内存。
> - **修改 (Modify)**: 更改已存储的数据。
> - **检索 (Retrieve)**: 读取内存中的数据以供使用。

> [!example] **一个生动的比喻：带编号的储物柜**
> > 我们可以将内存想象成一排排带编号的**储物柜**。
> > - **储物柜本身 (Memory System)**: 整个物理内存系统。
> > - **每个小柜子 (Memory Location)**: 内存中的一个存储单元。
> > - **柜子的编号 (Address)**: 每个存储单元的唯一地址。
> > - **柜子里的物品 (Data)**: 存储在单元中的具体信息。
> >
> > ![Memory Analogy](https://i.imgur.com/81Y0B3s.png)

---

### Ⅱ. 核心概念：地址 (Address) vs. 数据 (Data)

> [!question] 这是理解内存工作方式最关键的一点。

- **地址 (Address)**
    - **含义**: **“在哪里”**。地址是每个内存单元的**唯一标识符或位置编号**。当CPU想要读写内存时，它必须首先通过地址总线，指定要操作的是哪一个“储物柜”。
    - **特点**: 地址是唯一的，按顺序排列（如图中的0, 1, 2, ..., 11）。

- **数据 (Data)**
    - **含义**: **“是什么”**。数据是实际存储在特定地址单元中的**二进制信息内容**。它可能是程序指令、一个变量的数值、或者一段文本的编码。

**结论**: **地址**告诉CPU去哪里找，**数据**是CPU找到的东西。

---

### Ⅲ. 内存系统的设计权衡 (Trade-offs)

> [!tip]
> 世界上没有完美的内存技术，所有的物理存储介质都是在几个关键指标之间进行权衡和取舍。

- **速度 (Speed)**: 读写数据的快慢。速度越快越好，但通常成本也越高。（例如：CPU寄存器 > L1/L2缓存 > RAM > SSD硬盘）
- **成本 (Cost)**: 每单位存储容量（如每GB）的价格。
- **功耗 (Power Consumption)**: 内存工作时消耗的能量。对于手机、笔记本等电池供电的设备尤其重要。
- **尺寸/容量 (Size/Capacity)**: 能够存储的数据总量。

正因为存在这些权衡，计算机通常会采用一个**内存层级 (Memory Hierarchy)** 结构，将少量高速、昂贵的内存（如CPU缓存）与大量低速、廉价的内存（如RAM和硬盘）组合使用，以实现最佳的整体性能。

---

### Ⅳ. 具体实例：mbed平台的32位系统

> [!help]
> **"For our mbed both address and data are of 32 bits each."**
> (在我们的mbed平台中，地址和数据都是32位的。)

这句话提供了两条重要的技术信息：

- **32位数据 (32-bit Data)**:
    - **含义**: 内存中的每一个“储物柜”（存储单元）可以存放一个**32位的二进制数**。
    - **影响**: 这决定了单个内存单元可以表示的数值范围，以及处理器单次操作可以处理的数据宽度。

- **32位地址 (32-bit Address)**:
    - **含义**: 用于给“储物柜”编号的地址，其长度是**32位**。
    - **影响**: 这决定了CPU**总共能访问多大的内存空间**。
        - 32位二进制数总共可以表示 $2^{32}$ 个不同的地址。
        - $2^{32} = 4,294,967,296$ 个地址。
        - 如果每个地址对应1个字节（Byte）的数据，那么总的可寻址内存空间就是 **4 GB (Gigabytes)**。
    - **结论**: 这就是为什么我们常说“32位操作系统最多只能支持4GB内存”的根本原因。

![[Pasted image 20250811152831.png]]

# 笔记：计算机内存核心术语 (Memory Terminology)

> [!abstract] 核心纲要
> 本笔记旨在深入剖析计算机内存的几个核心术语。我们将从最小的存储单元**“位（Bit）”**开始，逐步构建到**“字节（Byte）”**和**“字（Word）”**的概念，并最终解释如何通过**“地址（Address）”**来对内存进行**读（Read）**和**写（Write）**操作。

---

### Ⅰ. 内存的存储单元 (The Building Blocks)

> [!info]
> 内存是由无数个微小的电子开关构成的，我们从最小的单位开始了解。

> [!check] **1. 内存单元 (Memory Cell) -> 位 (Bit)**
> > - **定义**: 内存中最基本的、最小的存储单位。它是一个可以存储**1位 (bit)** 二进制信息的电路。
> > - **直观比喻**: 想象一个最简单的**电灯开关**。它只有两种状态：“开 (ON)” 代表 `1`，或 “关 (OFF)” 代表 `0`。一个内存单元就相当于这样一个开关。

> [!check] **2. 字节 (Byte)**
> > - **定义**: 一个由**8个位 (bit)** 组成的标准信息单位。
> > - **意义**: 字节是计算机世界中衡量数据大小的**通用“货币”**。例如，一个英文字母（在ASCII编码中）通常占用1个字节，一个汉字占用2个或更多字节。文件大小、硬盘容量等都以字节（KB, MB, GB）为单位。

> [!check] **3. 内存字 (Memory Word)**
> > - **定义**: CPU在一次操作中能够处理的**标准数据块**，其长度通常为**8到64位**。
> > - **与CPU的关系**: “字长”是一个与CPU架构紧密相关的概念。
> >   - 一个**8位**的微控制器，其“字长”就是8位。
> >   - 一个**32位**的处理器（如ARM Cortex-M4），其“字长”就是32位。
> >   - 一个**64位**的处理器（如Intel Core i9），其“字长”就是64位。
> > - **直观比喻**: 如果说“位”是一块砖，“字”就是处理器一次能搬运的一整车砖。64位的CPU一次能搬运64块砖，效率更高。

---

### Ⅱ. 内存的访问机制 (How We Access Memory)

> [!example]
> 图中的表格展示了8个内存字，以及它们各自的地址。

> [!help] **4. 地址 (Address)**
> > - **定义**: 内存中每个存储位置（通常是一个**内存字**）的**唯一编号**。
> > - **作用**: CPU通过这个“地址”来精确地**定位**要访问的数据。就像你通过门牌号找到一间具体的房子一样。
> > - **图中示例**:
> >   - 图中有**8个**内存字（Word 0 到 Word 7）。
> >   - 为了给8个不同的位置进行唯一编号，我们需要 $log_2(8) = 3$ 个二进制位。
> >   - 因此，地址使用了3位二进制数，从 `000` (十进制的0) 到 `111` (十进制的7)，分别对应Word 0到Word 7。

> [!success] **5. 读/写操作 (Read/Write Operations)**
> > 这是CPU与内存交互的两种基本动作。
> >
> > > [!todo] **读操作 (Read / Fetch)**
> > > - **过程**: CPU向内存系统发送一个**地址**，请求获取该地址上的数据。内存系统找到对应的位置，将其中的数据**复制**一份，通过数据总线发送给CPU。
> > > - **特点**: **非破坏性**。读取操作不会改变内存中原有的数据。
> >
> > > [!todo] **写操作 (Write / Store)**
> > > - **过程**: CPU向内存系统同时发送一个**地址**和要存入的**新数据**。内存系统找到对应的位置，用新数据**覆盖**掉该位置上原有的旧数据。
> > > - **特点**: **破坏性**。写入操作会永久地改变内存中的数据。

> [!summary] **总结**
> 计算机内存可以看作是一个由大量**内存字 (Memory Word)** 组成的巨大数组。每个内存字都有一个唯一的**地址 (Address)**。CPU通过指定地址，可以对任何一个内存字执行**读 (Read)** 或**写 (Write)** 操作，从而实现对数据的存储和检索。


![[Pasted image 20250811153115.png]]

![[Pasted image 20250811153149.png]]

![[Pasted image 20250811153237.png]]

# 笔记：计算机内存层级 (Memory Hierarchy)

> [!abstract] 核心思想：一个无法实现的“理想内存”与一个聪明的“妥协方案”
> - **理想的内存**: 我们希望计算机的内存速度**无限快**、容量**无限大**、而且**免费**。
> - **现实的矛盾**: 物理定律决定了，**速度越快的存储介质，每单位容量的成本就越高，且体积越大、功耗越高**。
> - **聪明的解决方案**: **内存层级 (Memory Hierarchy)**。计算机不使用单一类型的内存，而是将少量**高速、昂贵**的内存与大量**低速、廉价**的内存组合起来，形成一个金字塔结构。其高效运作的秘诀在于**局部性原理 (Principle of Locality)**，即CPU当前需要的数据，有极大概率就在刚刚访问过的数据附近。

---

### Ⅰ. 金字塔的规律

> [!info]
> 观察金字塔图旁的箭头，我们可以发现三条清晰的规律。从**金字塔顶端到底部**：
> - 💨 **速度 (Speed)**: **越来越慢** (访问延迟越来越高)。
> - 💰 **价格 (Price)**: 每比特（Bit）的存储**成本越来越低**。
> - 💾 **容量 (Capacity)**: 存储**容量越来越大**。

---

### Ⅱ. 内存层级详解：从上到下

> [!example]
> 我们来逐层解析金字塔中的每一个层级。

> [!tip] **顶层 1: CPU寄存器 (CPU Registers)**
> > - **位置**: 直接集成在**CPU核心内部**。
> > - **速度**: **最快**，与CPU同速，访问几乎没有延迟。
> > - **容量**: **极小**（通常只有几十到几百字节）。
> > - **易失性**: **易失性 (Volatile)**，断电后数据立即丢失。
> > - **作用**: 存放CPU**当前正在执行**的指令和操作数（数据）。它是CPU的“指尖”，直接处理眼前的任务。

> [!help] **顶层 2: CPU缓存 (CPU Cache - SRAM)**
> > - **位置**: 集成在CPU芯片上，紧邻CPU核心。
> > - **速度**: **极快**，仅次于寄存器。
> > - **容量**: **很小**（通常为几KB到几十MB）。
> > - **易失性**: **易失性 (Volatile)**。
> > - **作用**: 充当CPU和主内存之间的**高速缓冲区**。它存放着CPU**最有可能在接下来马上需要**的数据和指令块。当CPU需要数据时，会先在缓存中查找，如果找到（缓存命中），就可以避免去访问慢得多的主内存。

> [!note] **中间层: 主内存 (Main Memory - DRAM)**
> > - **位置**: 插在主板上的独立内存条（我们通常所说的“内存”）。
> > - **速度**: 比CPU缓存**慢得多**，但比硬盘快得多。
> > - **容量**: **较大**（通常为几GB到几十GB）。
> > - **易失性**: **易失性 (Volatile)**。
> > - **作用**: 计算机的**主要工作区**。它存放着当前正在运行的**操作系统、所有应用程序及其数据**。

> [!success] **底层 1: 闪存/本地存储 (Flash/Local Storage)**
> > - **位置**: 计算机的硬盘驱动器（如SSD固态硬盘或HDD机械硬盘）。
> > - **速度**: 比主内存**慢得多**。
> > - **容量**: **巨大**（通常为几百GB到几TB）。
> > - **易失性**: **非易失性 (Non-Volatile)**，断电后数据**会保留**。
> > - **作用**: 计算机的**长期档案馆**。它永久性地存储着**操作系统、所有已安装的程序和用户文件**（文档、照片、视频等）。

> [!summary] **底层 2: 外部存储 (External Storage)**
> > - **位置**: 可移动设备或网络存储。
> > - **速度**: **最慢**。
> > - **容量**: **非常大**，可无限扩展。
> > - **易失性**: **非易失性 (Non-Volatile)**。
> > - **作用**: 主要用于**数据备份、归档和在不同设备间传输文件**。
> > - **例子**: U盘、移动硬盘、网络附加存储(NAS)、云存储等。

![[Pasted image 20250811153514.png]]
![[Pasted image 20250811153543.png]]

# 笔记：计算机内存类型全解析 (RAM vs. ROM)

> [-abstract] 核心纲要
> 本笔记旨在深入剖析计算机内存的两大家族：**RAM（随机存取存储器）**和**ROM（只读存储器）**。我们将重点关注：
> 1.  **RAM vs. ROM** 的根本区别：**易失性 (Volatility)** 与**读写能力**。
> 2.  **RAM** 的两大分支：**SRAM（静态RAM）**与**DRAM（动态RAM）**的原理、性能和应用场景的深度对比。
> 3.  **ROM** 的技术演进：从真正的“只读”到可重复编程的 **EEPROM** 和 **Flash**。

---

### Ⅰ. 内存的两大家族：RAM 与 ROM

> [!info]
> 计算机内存根据其掉电后能否保存数据（易失性）以及其主要用途，可以被清晰地分为两大类。

> [!tip] **RAM (Random Access Memory) - 计算机的“工作台 / 草稿纸”**
> > - **核心功能**: 可以在计算机**正常运行期间**被**反复读取和写入**。
> > - **关键特性**: **易失性 (Volatile)**。这意味着一旦**断电**，其中存储的所有数据都会**立即丢失**。
> > - **主要用途**: 作为**主内存**，存放操作系统、当前正在运行的程序和临时数据。
> > - **两大类型**: **静态RAM (Static RAM)** 和 **动态RAM (Dynamic RAM)**。

> [!success] **ROM (Read-Only Memory) - 计算机的“说明书 / 固件”**
> > - **核心功能**: 传统上，ROM在被制造或编程一次后，其内容就是**永久性的**，不能被轻易修改或删除。
> > - **关键特性**: **非易失性 (Non-Volatile)**。**断电**后，数据**依然会保留**。
> > - **主要用途**: 存放计算机启动所需的**引导程序 (BIOS/UEFI)**、**固件 (Firmware)** 等轻易不会改变的核心指令。

---

### Ⅱ. RAM的深度对比：SRAM vs. DRAM

> [!example]
> SRAM和DRAM是构成现代计算机内存层级的核心，但它们的内部原理、性能和成本差异巨大。

> [!check] **SRAM (Static RAM - 静态随机存取存储器)**
> > - **“静态”的含义**: 只要有电供给，它就能**一直保持**其中存储的数据，**不需要**周期性的刷新。
> > - **工作原理**: 其基本存储单元是一个**锁存器 (Latch)** 或触发器，通常由**6个晶体管**构成。
> >   - **比喻**: 像一个**物理开关**。你把它拨到“开”的位置，只要不停电，它就永远是“开”，直到你再次去拨动它。
> > - **核心特点**:
> >   - **速度极快**: 是所有RAM中**访问速度最快**的。
> >   - **成本高昂**: 每个位需要6个晶体管，结构复杂，集成度低，导致价格昂贵。
> >   - **功耗较高**: 静态功耗相对较高。
> > - **主要应用**: 因其高速特性，主要用于构建CPU内部的**高速缓存 (Cache Memory)**，如L1, L2, L3 Cache。

> [!danger] **DRAM (Dynamic RAM - 动态随机存取存储器)**
> > - **“动态”的含义**: 它利用微型**电容器 (Capacitor)** 来存储电荷以表示数据`1`或`0`。但电容器会**漏电**，所以必须在数据丢失前，**周期性地、不断地对其进行“刷新”(Refresh)** 来重新充电。
> > - **工作原理**: 其基本存储单元由 **1个晶体管和1个电容器**构成，结构极其简单。
> >   - **比喻**: 像一个**带小洞的迷你水桶**。你往里装满水（充电，代表`1`），但水会慢慢漏掉。你必须每隔一小段时间（不到一毫秒）就检查一次，如果水快漏光了，就赶紧把它**重新加满**。
> > - **核心特点**:
> >   - **速度较慢**: 相对于SRAM，速度要慢。
> >   - **成本低廉**: 结构简单，可以在同样大小的芯片上集成比SRAM多得多的存储单元（高密度）。
> >   - **功耗较低**: 静态功耗低。
> > - **主要应用**: 因其高密度和低成本，成为了计算机**主内存（我们常说的“内存条”）**的标准技术。
> > - **进阶类型**:
> >   - **SDRAM**: **同步**DRAM，其工作与系统时钟同步。
> >   - **DDR (Double Data Rate)**: 能在时钟信号的**上升沿和下降沿**都传输数据，速度翻倍。
> >   - **QDR (Quad Data Rate)**: 速度是DDR的两倍。

---

### Ⅲ. ROM的技术演进

> [!help]
> “只读存储器”这个名字具有历史性。现代的“ROM”很多已经变得可以被用户修改了。

- **PROM (Programmable ROM)**: 用户可以自己**编程一次**。像一张只能刻录一次的CD-R。
- **EPROM (Erasable Programmable ROM)**: 可以通过**紫外线 (ultraviolet light)** 照射来**擦除**全部数据，然后重新编程。擦除过程很不方便。
- **EEPROM (Electrically Erasable Programmable ROM)**: **现代ROM的主流**。可以通过**电信号**来擦除和重写数据，无需特殊设备。
    - **Flash Memory (闪存)**: 是EEPROM的一种变体，针对**大块数据**的擦写进行了优化。我们日常使用的**U盘、SSD固态硬盘以及手机存储**，其核心技术都是Flash Memory。

![[Pasted image 20250811153804.png]]
![[Pasted image 20250811153841.png]]
![[Pasted image 20250811153911.png]]

![[Pasted image 20250811153946.png]]# 笔记：Cortex-M4内存映射与闪存 (Memory Mapping & Flash Memory)

> [!abstract] 核心纲要
> 本笔记旨在深入剖析微控制器（MCU）中一个至关重要的概念——**内存映射 (Memory Mapping)**。我们将重点关注：
> 1.  **什么是内存映射**：为何它是一种高效管理硬件资源的技术。
> 2.  **Cortex-M4的内存地图**: 详细解析其 **4GB** 地址空间是如何被划分为代码区、SRAM区、外设区等六大功能区域的。
> 3.  **闪存 (Flash Memory) 详解**: 深入了解作为程序存储区主要技术的闪存的特性、优点和局限性。

---

### Ⅰ. 什么是内存映射 (Memory Mapping)？

> [!info]
> **定义**: **内存映射**是一种在微控制器中用于高效管理和分配内存资源的技术。它的核心思想是，**为芯片上每一个硬件组件（RAM, ROM, 各种外设）都分配一段唯一的内存地址**。

> [!example] **一个生动的比喻：给城市里的所有建筑编号**
> > 想象一下，一个微控制器就是一座城市，里面的各种功能模块（CPU、内存、定时器、I/O端口）就是城市里的不同建筑（市政厅、图书馆、邮局、消防站）。
> >
> > **内存映射**就相当于给这座城市里的**每一栋建筑**都分配了一个**唯一的、固定的门牌号（内存地址）**。
> >
> > - **CPU（市长）**想要读取数据，就去**图书馆（RAM地址）**。
> > - CPU想要执行程序，就去**档案馆（代码/Flash地址）**。
> > - CPU想要控制一个LED灯，就直接向**路灯管理处（GPIO端口地址）**发送一个指令。

> [!success] **核心优势：内存映射I/O (Memory-Mapped I/O)**
> > 通过这种方式，CPU可以像访问普通内存一样，通过简单的**读/写内存指令**来访问和控制所有的硬件外设（如GPIO, TIMERS, ADC）。CPU不需要设计复杂的、专门的I/O指令，极大地简化了处理器的设计和软件编程。

---

### Ⅱ. Cortex-M4的内存地图：一个4GB的地址空间

> [!tip]
> ARM Cortex-M4处理器拥有**32位的地址总线**，这意味着它可以访问的地址范围是 $2^{32}$ 个字节，即 **4 GB** 的巨大空间。这个空间被预先规划成六大功能区域。



> [!check] **六大功能区域详解**
> 1. **代码区 (Code Region) - `0.5 GB`**:
>    - **地址范围**: `0x00000000` - `0x1FFFFFFF`
>    - **作用**: 存放**程序代码**。
>    - **典型硬件**: **片上闪存 (On-chip Flash)**。
>
> 2. **SRAM区 - `0.5 GB`**:
>    - **地址范围**: `0x20000000` - `0x3FFFFFFF`
>    - **作用**: 片上静态RAM，用于程序运行时的**变量存储、栈空间**等，提供快速的数据访问。
>    - **典型硬件**: **片上SRAM (On-chip SRAM)**。
>
> 3. **外设区 (Peripheral Region) - `0.5 GB`**:
>    - **地址范围**: `0x40000000` - `0x5FFFFFFF`
>    - **作用**: **内存映射I/O的核心区域**。芯片上所有的外设（GPIO, 定时器, ADC, I2C, UART等）的控制寄存器，都被映射到这段地址上。
>
> 4. **外部RAM区 (External RAM) - `1 GB`**:
>    - **地址范围**: `0x60000000` - `0x9FFFFFFF`
>    - **作用**: 用于连接**片外 (Off-chip)** 的扩展RAM，以应对片上SRAM容量不足的情况。
>
> 5. **外部设备区 (External Devices) - `1 GB`**:
>    - **地址范围**: `0xA0000000` - `0xDFFFFFFF`
>    - **作用**: 用于连接**片外**的其他设备，如扩展的Flash存储器、LCD显示控制器等。
>
> 6. **系统区 (System Region) - `0.5 GB`**:
>    - **地址范围**: `0xE0000000` - `0xFFFFFFFF`
>    - **作用**: 存放ARM Cortex-M4内核的**核心系统组件**，如**NVIC（嵌套向量中断控制器）**、**System Tick定时器**等，程序员通常不直接操作此区域。

---

### Ⅲ. 闪存 (Flash Memory) 详解

> [!note]
> 闪存是现代微控制器中用于**存储程序代码 (Code Region)** 的主流技术。

> [!list] **闪存的核心特性**
> - **RAM/ROM的混合体**: 它像ROM一样，是**非易失性**的（断电不丢数据）；又像RAM一样，可以被**电信号**擦除和重写。
> - **块擦除 (Block Erasure)**: 闪存的一个关键特性是，**不能按字节擦除**。在写入新数据前，必须先将**一整块 (block) 或整片芯片**的数据一次性擦除。
> - **有限的擦写寿命 (Limited Erase Cycles)**: 每个闪存单元只能承受有限次数的擦写操作（通常是1万到10万次）。因此，像SSD这样的设备需要复杂的算法（如磨损均衡）来管理闪存寿命。
> - **速度特性**: 它的**写入速度**通常受限于其较慢的擦除速度，因此比RAM慢，但远比传统的机械硬盘快。
> - **广泛应用**: **SSD固态硬盘、U盘、SD卡**以及绝大多数微控制器（如 **Mbed 平台**）都使用闪存来存储程序或数据。


![[Pasted image 20250811155616.png]]
![[Pasted image 20250811155546.png]]

# 笔记：计算机总线与内存架构 (Buses & Memory Architectures)

> [!abstract] 核心纲要
> 本笔记旨在深入剖析处理器（CPU）与内存之间的通信机制。我们将重点关注：
> 1.  **总线 (Buses)**: 计算机内部的“多车道高速公路”，了解地址、数据和控制总线各自的职责。
> 2.  **冯·诺依曼架构 (von Neumann)**: 指令和数据共享内存与总线的传统计算机架构。
> 3.  **哈佛架构 (Harvard)**: 指令和数据拥有独立内存与总线的高性能微控制器架构。

---

### Ⅰ. 计算机的“高速公路”：理解总线 (Buses)

> [!info]
> **定义**: **总线**是连接计算机各个组件（如CPU、内存、其他设备）的一组共享的**并行导线**，就像一条“**多车道高速公路**”，负责传输信息。

> [!example] **总线的三种主要类型**
> 我们可以将一次内存访问操作，比作一次“**快递派送**”过程。

> [!check] **1. 地址总线 (Address Bus)**
> > - **角色**: **快递单上的“地址”**。
> > - **功能**: 专门用于**承载地址信息**。CPU通过地址总线，告诉内存系统它想要访问**哪一个**具体的存储单元。
> > - **方向**: **单向的 (Uni-directional)**。地址信号总是**从CPU发出**，流向内存或外设。
> > - **寻址能力**: 地址总线的“宽度”（有多少根线，即k-bits）决定了CPU能访问多大的内存空间。`k`位地址总线可以访问 **$2^k$** 个不同的内存位置。

> [!check] **2. 数据总线 (Data Bus)**
> > - **角色**: **运送“包裹”的卡车**。
> > - **功能**: 专门用于**承载真实的二进制数据**。
> > - **方向**: **双向的 (Bi-directional)**。
> >   - **读操作 (Read)**: 数据**从内存**流向CPU。
> >   - **写操作 (Write)**: 数据**从CPU**流向内存。

> [!check] **3. 控制总线/线 (Control Lines)**
> > - **角色**: **“交通信号灯”和“调度指令”**。
> > - **功能**: 负责传递**控制和时序信号**，确保数据传输的协调与同步。
> > - **作用**:
> >   - **指定操作类型**: 发出“读取”或“写入”的命令。
> >   - **时序同步**: 确保CPU和内存在正确的时间点发送和接收数据。
> >   - **总线仲裁**: 确保同一时刻只有一个设备在使用总线，避免信号冲突。

---

### Ⅱ. 内存架构：两种不同的“图书馆”设计

> [!question]
> 计算机的“指令”（程序代码）和“数据”（变量）都存在内存里，那么这两种信息是如何被组织和访问的呢？这主要有两种设计哲学。

> [!tip] **冯·诺依曼架构 (von Neumann Architecture)**
> > - **核心思想**: **指令和数据不加区分，存放在同一个物理内存中，共享同一组总线**。
> > - **比喻**: 一个巨大的**综合图书馆**。无论是“操作指南”（指令）还是“研究资料”（数据），都存放在同一个大楼的书架上，并且所有人都必须通过**同一个大门和走廊**（共享总线）来存取。
> > - **工作流程**: CPU必须**依次**进行操作：1. 通过总线去获取指令 -> 2. 再通过**同一条总线**去获取该指令所需的数据。
> > - **优缺点**:
> >   - **优点**: 硬件结构简单，实现灵活。
> >   - **缺点**: **“冯·诺依曼瓶颈”**。因为共用一条总线，取指令和取数据无法同时进行，总线成为了性能瓶颈。
> > - **主要应用**: **通用计算机 (Computers)**，如PC和服务器。

> [!success] **哈佛架构 (Harvard Architecture)**
> > - **核心思想**: **将指令和数据分别存放在两个独立的物理内存中，并为它们配备各自专用的总线**。
> > - **比喻**: 一个拥有**两栋独立大楼**的图书馆。一栋是“**指令档案馆**”（程序内存），另一栋是“**数据资料室**”（数据内存）。每栋楼都有**自己独立的出入通道**（独立总线）。
> > - **工作流程**: CPU可以**同时进行**两个操作：1. 通过指令总线去“指令档案馆”获取**下一条**要执行的指令 -> 2. **与此同时**，通过数据总线去“数据资料室”存取**当前**指令所需的数据。
> > - **优缺点**:
> >   - **优点**: **性能更高**。并行操作打破了“冯·诺依曼瓶颈”，指令执行效率大大提升。
> >   - **缺点**: 硬件结构相对复杂。
> > - **主要应用**: **微控制器 (Microcontrollers)** 和数字信号处理器 (DSP)，这些设备通常对执行速度和确定性有更高的要求。

> [!summary] **总结对比**
| 特性 | 冯·诺依曼架构 | 哈佛架构 |
| :--- | :--- | :--- |
| **内存** | 指令和数据混合存储，共用一个内存空间 | 指令和数据分开存储，拥有独立的内存空间 |
| **总线** | **共享**地址和数据总线 | 指令和数据总线各自**独立** |
| **访问方式** | 串行（依次获取指令和数据） | **并行**（可同时获取指令和数据） |
| **性能** | 存在“冯·诺依曼瓶颈”，速度受限 | 效率更高，速度更快 |
| **主要应用** | **通用计算机** | **微控制器、DSP** |

![[Pasted image 20250811162318.png]]
