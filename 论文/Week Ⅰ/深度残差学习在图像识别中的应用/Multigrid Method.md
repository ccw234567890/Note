# 算法：多重网格法 (Multigrid Method)

**标签**: #数值分析 #线性代数 #PDE #算法

> [!info] 核心思想
> **多重网格法（Multigrid Method, MG）** 是一种高效求解大规模线性方程组（尤其是源于偏微分方程离散化）的迭代算法。其核心思想是“**分而治之**”：
> 
> 想象一下修复一幅巨大的、有瑕疵的画。你可以：
> 1.  **近看修复 (细网格)**: 用小刷子仔细修复画作的局部细节瑕疵。但这很难看清画作的整体色调和结构性偏差。
> 2.  **远看修复 (粗网格)**: 退后几步，眯起眼睛看，画作的整体、大范围的瑕疵（比如一边偏暗）就变得很明显。你用大刷子快速修正这些整体偏差。
> 
> 多重网格法正是利用了这一思想：**在高分辨率的“细网格”上消除高频误差（局部细节瑕疵），在低分辨率的“粗网格”上消除低频误差（整体结构性偏差）**。通过在不同“分辨率”的网格间切换，实现对所有频率误差的快速消除。

---

## 1. 为什么需要多重网格法？

在求解形如 $A\mathbf{u} = \mathbf{f}$ 的线性方程组时，经典的迭代法（如 [[雅可比迭代]] 或 [[高斯-赛德尔迭代]]）存在一个严重问题。

- **问题**: 这些方法被称为**平滑算子 (Smoother)**，因为它们能非常**快速地消除高频误差**（解中快速振荡的分量），但对于**低频误差**（解中平缓、大范围变化的分量）的收敛速度**极其缓慢**。

> **关键洞察**: 在细网格上看起来“平滑”的低频误差，如果把它转移到一个更粗糙的网格上，它就可能不再“平滑”，而变成了“高频”误差，从而可以被同样的平滑算子高效地消除。

![Error Smoothing](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Multigrid_smoothing.svg/500px-Multigrid_smoothing.svg.png)
*上图：平滑操作快速消除高频误差，留下难以处理的低频误差。*

---

## 2. 多重网格法的核心组件

一个完整的多重网格循环包含以下几个关键操作：

1.  **平滑 (Smoothing)**
    - **目的**: 消除当前网格上的高频误差。
    - **方法**: 在当前解上进行几步简单的迭代，如高斯-赛德尔（Gauss-Seidel）或带权重的雅可比（Weighted Jacobi）迭代。
    - **公式 (以高斯-赛德尔为例)**: 对 $A\mathbf{u}=\mathbf{f}$ 进行迭代更新 $\mathbf{u}^{(k+1)}$。

2.  **限制 (Restriction)**
    - **目的**: 将细网格上的问题“降采样”到粗网格上。
    - **过程**:
        1. 计算细网格上的**残差 (Residual)**: $\mathbf{r}_h = \mathbf{f}_h - A_h \mathbf{u}_h$ (这里的 $h$ 表示细网格)。残差代表了当前解“错得有多离谱”。
        2. 将残差 $\mathbf{r}_h$ 通过一个**限制算子 $I_h^{2h}$** 传递到粗网格（$2h$）上，得到 $\mathbf{r}_{2h} = I_h^{2h} \mathbf{r}_h$。
    - **限制算子**: 可以是简单的取平均值、加权平均等。

3.  **粗网格求解 (Coarse-Grid Solve)**
    - **目的**: 在粗网格上求解由残差构成的方程。
    - **过程**:
        - 细网格上的误差 $\mathbf{e}_h$ 与残差 $\mathbf{r}_h$ 的关系是 $A_h \mathbf{e}_h = \mathbf{r}_h$。
        - 我们的目标是在粗网格上近似求解这个误差方程，即 $A_{2h} \mathbf{e}_{2h} = \mathbf{r}_{2h}$。
        - 这个方程的维度远小于原始问题，求解成本低得多。
        - **如何求解？** 如果粗网格足够粗，可以直接求解。否则，**递归地再次调用多重网格法**！

4.  **延拓 (Prolongation / Interpolation)**
    - **目的**: 将粗网格上计算出的误差修正值“升采样”回细网格。
    - **过程**: 将粗网格上的解（误差的近似）$\mathbf{e}_{2h}$ 通过一个**延拓算子 $I_{2h}^h$** 插值回细网格，得到误差修正量 $\mathbf{e}_h^{correction} = I_{2h}^h \mathbf{e}_{2h}$。
    - **延拓算子**: 可以是线性插值、双线性插值等。
    - **校正**: 用这个修正量来更新细网格上的解: $\mathbf{u}_h^{new} = \mathbf{u}_h^{old} + \mathbf{e}_h^{correction}$。

5.  **后平滑 (Post-Smoothing)**
    - **目的**: 经过延拓操作后，可能会引入一些新的高频误差。需要再次使用平滑算子清理这些“插值噪声”。
    - **方法**: 与第一步的平滑操作相同。

---

## 3. 多重网格循环 (Multigrid Cycles)

将上述组件组合起来，就形成了一个多重网格的迭代循环。最常见的是 **V-Cycle**。

### V-Cycle 算法流程
假设有一个函数 `MG_V(A_h, f_h, u_h)`，它在网格 $h$ 上求解 $A_h\mathbf{u}_h=\mathbf{f}_h$。

1.  **前平滑 (Pre-smoothing)**:
    - 对 $\mathbf{u}_h$ 进行 $\nu_1$ 次平滑迭代。

2.  **计算残差**:
    - $\mathbf{r}_h = \mathbf{f}_h - A_h \mathbf{u}_h$。

3.  **限制残差**:
    - $\mathbf{r}_{2h} = I_h^{2h} \mathbf{r}_h$。

4.  **粗网格求解**:
    - **递归调用**: 在粗网格上求解误差方程 $A_{2h}\mathbf{e}_{2h} = \mathbf{r}_{2h}$。
    - `e_2h` 初始化为 0。
    - **如果** `2h` 是最粗的网格，则直接求解 (如用高斯消元)。
    - **否则**，递归调用 `e_2h = MG_V(A_2h, r_2h, e_2h)`。

5.  **延拓并校正**:
    - 将粗网格解 $\mathbf{e}_{2h}$ 延拓回细网格: $\mathbf{e}_h^{correction} = I_{2h}^h \mathbf{e}_{2h}$。
    - 校正细网格解: $\mathbf{u}_h \leftarrow \mathbf{u}_h + \mathbf{e}_h^{correction}$。

6.  **后平滑 (Post-smoothing)**:
    - 对更新后的 $\mathbf{u}_h$ 进行 $\nu_2$ 次平滑迭代。

7.  **返回** 更新后的 $\mathbf{u}_h$。

![V-cycle](https://upload.wikimedia.org/wikipedia/commons/thumb/6/64/Multigrid_V-cycle.svg/400px-Multigrid_V-cycle.svg.png)
*V-Cycle 示意图：从细到粗（限制），再从粗到细（延拓），形如一个 "V" 字。*

---

## 4. 优势总结

- **极高的效率**: 多重网格法的收敛速度**与问题规模（网格大小）无关**。这意味着，即使你将网格加密一倍，达到同样精度所需的迭代次数几乎不变。这使得它的计算复杂度是 $O(N)$，其中 $N$ 是未知数的数量，这是最优的。
- **通用性**: 可用于求解椭圆型偏微分方程、积分方程等多种问题。
- **并行性**: 算法的许多部分（如平滑、残差计算）具有很好的并行潜力。

## 关联概念
- [[偏微分方程 (PDE)]]
- [[线性方程组]]
- [[高斯-赛德尔迭代]]
- [[雅可比迭代]]
- [[有限差分法]]
- [[有限元法]]