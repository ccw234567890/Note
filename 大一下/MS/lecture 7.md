![[Pasted image 20250811230557.png]]![[Pasted image 20250811230644.png]]
![[Pasted image 20250811230805.png]]
![[Pasted image 20250811230853.png]]
![[Pasted image 20250811230956.png]]
![[Pasted image 20250811231037.png]]

# 笔记：二进制信息表示法 (Binary Representation of Information)

> [!abstract] 核心纲要
> 本笔记旨在深入剖析数字信息世界的最基本单元——**二进制**。我们将重点关注：
> 1.  **位 (Bit)** 的定义，以及 `n` 个位如何以 **$2^n$** 的形式指数级地扩展信息容量。
> 2.  二进制的第一个核心应用：**表示数字**，以及二进制与十进制的转换原理。
> 3.  二进制的第二个核心应用：**控制数据流**，引出后续的数字逻辑电路。
> 4.  二进制的物理实现：抽象的 `1` 和 `0` 如何对应到电路中的**高低电平**。

---

### Ⅰ. 基础概念：位 (Bit) 与组合的力量

> [!info]
> 在计算机中，所有信息和数据，最终都以 **`1` 和 `0` 的组合**形式来表示。

> [!check] **1. 位 (Bit)**
> > - **定义**: **信息的最小单位**。一个“位”的值只能是 `1` 或 `0`。

> [!check] **2. 组合的可能性呈指数级增长**
> > - **`2ⁿ` 规则**: `n` 个位可以表示 **$2^n$** 种不同的组合。
> > - **示例**:
> >   - **1 位** ($b_0$): 可表示 $2^1=2$ 种状态 (`0`, `1`)。
> >   - **2 位** ($b_1b_0$): 可表示 $2^2=4$ 种状态 (`00`, `01`, `10`, `11`)。
> >   - **3 位** ($b_2b_1b_0$): 可表示 $2^3=8$ 种状态 (`000` 到 `111`)。
> >   - **4 位**: 可表示 $2^4=16$ 种状态 (`0000` 到 `1111`)。
> >
> > **这个指数增长的特性，是二进制能够表示复杂信息的根本原因。**

---

### Ⅱ. 应用一：表示数字 (Binary Number Representation)

> [!example]
> 为了理解二进制，我们可以先回顾一下我们熟悉的十进制。

> [!tip] **十进制 (Decimal System)**
> > - **符号**: 使用 `0` 到 `9` 共10个符号。
> > - **权重**: 每一个数位都有一个基于**10的幂次方**的权重。
> > - **示例**: `(5003)₁₀ = (5 × 10³) + (0 × 10²) + (0 × 10¹) + (3 × 10⁰)`

> [!success] **二进制 (Binary System)**
> > - **符号**: 只使用 `0` 和 `1` 共2个符号。
> > - **权重**: 每一个数位都有一个基于**2的幂次方**的权重。
> > - **示例**: `(101)₂`
> >   - `(1 × 2²) + (0 × 2¹) + (1 × 2⁰)`
> >   - `= (1 × 4) + (0 × 2) + (1 × 1)`
> >   - `= 4 + 0 + 1 = 5` (十进制)
>
> 

---

### Ⅲ. 物理世界的实现：逻辑电平 (Logic Levels)

> [!question] 在电子电路中，抽象的 `1` 和 `0` 到底是什么？

> [!answer]
> 它们由**电压的高低**来表示。
> - **逻辑 `1` (高电平, High)**: 对应一个**较高的电压**，例如 **3.3V** 或 **5V**。
> - **逻辑 `0` (低电平, Low)**: 对应一个**较低的电压**，例如 **GND (地, `0V`)**。
>
> **图示中的“开关-灯泡”例子完美地展示了这一点**：一组8位的开关 `10101000`，通过电路转换成对应的高低电平信号，点亮了相应的灯泡，这些灯泡的亮灭状态直观地表示了二进制数每一位的权重，最终组合成了十进制数 `168`。

---

### Ⅳ. 应用二：控制数据流 (Controlling Data Flow)

> [!help]
> 除了表示数字，`1` 和 `0` 的组合在处理器和微控制器中更重要的作用是作为**控制信号**。

- **作用**: 一个二进制码可以作为一个**地址**，去选择特定的内存单元；也可以作为一个**指令**，去控制某个硬件模块执行特定操作。
- **实现**: 要实现这种复杂的控制，我们需要一系列的数字逻辑电路。
- **后续学习**: 这正是我们需要学习以下数字电路的原因：
  1.  **译码器 (Decoder)**
  2.  **编码器 (Encoder)**
  3.  **多路复用器 (Multiplexer)**
  4.  **多路解复用器 (Demultiplexer)**

![[Pasted image 20250811232036.png]]
![[Pasted image 20250811231717.png]]
![[Pasted image 20250811233204.png]]
![[Pasted image 20250811233317.png]]

# 笔记：译码器 (Decoder) 原理与实现

> [!abstract] 核心纲要
> 本笔记旨在深入剖析数字逻辑电路中的一个核心组件——**译码器 (Decoder)**。我们将重点关注：
> 1.  **译码器的定义**: 理解其“**n进2ⁿ出**”的核心功能。
> 2.  **实例解析**: 通过**1x2译码器**和**2x4译码器**的例子，逐步理解其工作原理。
> 3.  **底层实现**: 揭示译码器是如何通过**与门 (AND)**和**非门 (NOT)**等基础逻辑门搭建起来的。

---

### Ⅰ. 译码器是什么？- “代码翻译官”

> [!info]
> **定义**: **译码器 (Decoder)** 是一种数字逻辑电路，它能将一个 `n` 位的二进制输入信息，转换为最多 `2ⁿ` 条独立输出线中**唯一一个**高电平信号。

> [!example] **一个生动的比喻：公寓楼的门禁系统**
> > - **`n`位输入 (Inputs)**: 你在门禁键盘上输入的**房间号**（例如，3位的二进制码）。
> > - **译码器 (Decoder)**: 门禁系统的**中央控制器**。
> > - **`2ⁿ`条输出 (Outputs)**: 连接到大楼里每一户门锁的线路。
> >
> > **工作流程**: 当你输入房间号 `101`（十进制的5）时，译码器会**且仅会**向**第5户**的门锁发送一个“开锁”信号（高电平），而所有其他房间的门锁线路都保持无响应（低电平）。

---

### Ⅱ. 实例解析：从零开始构建译码器

#### **1. 最简单的译码器：1x2 Decoder**

> [!tip]
> - **功能**: 1位输入 (`a₀`)，2位输出 (`b₀`, `b₁`)。
> - **逻辑**:
>   - 当输入 `a₀ = 0` 时，输出 `b₀` 为 `1`。
>   - 当输入 `a₀ = 1` 时，输出 `b₁` 为 `1`。
> - **真值表**:
> ```
>   a₀ | b₀ | b₁
> ----+----+---
>   0  |  1 |  0
>   1  |  0 |  1
> ```

> [!success] **电路实现**
> > 这个译码器非常简单，只需要一个**非门 (Inverter)** 即可实现。
> > - 输出 `b₁` 直接连接到输入 `a₀`。
> > - 输出 `b₀` 连接到输入 `a₀` 经过一个非门之后的结果 (`Ā₀`)。
> >
> > 

#### **2. 更复杂的译码器：2x4 Decoder**

> [!help]
> - **功能**: 2位输入 (`a₁`, `a₀`)，4位输出 (`b₀`, `b₁`, `b₂`, `b₃`)。
> - **逻辑**: 根据输入的4种不同组合 (`00`, `01`, `10`, `11`)，依次激活 `b₀`, `b₁`, `b₂`, `b₃` 中的一个。
> - **真值表**:
> ```
>  a₁ | a₀ | b₀ | b₁ | b₂ | b₃
> ----+----+----+----+----+----
>  0  |  0 |  1 |  0 |  0 |  0
>  0  |  1 |  0 |  1 |  0 |  0
>  1  |  0 |  0 |  0 |  1 |  0
>  1  |  1 |  0 |  0 |  0 |  1
> ```

> [!success] **电路实现：2个非门 + 4个与门**
> > 我们可以为每一条输出线推导出其逻辑表达式：
> > - `b₀` 只有在 `a₁=0` **且** `a₀=0` 时才为1  =>  **`b₀ = Ā₁ · Ā₀`**
> > - `b₁` 只有在 `a₁=0` **且** `a₀=1` 时才为1  =>  **`b₁ = Ā₁ · a₀`**
> > - `b₂` 只有在 `a₁=1` **且** `a₀=0` 时才为1  =>  **`b₂ = a₁ · Ā₀`**
> > - `b₃` 只有在 `a₁=1` **且** `a₀=1` 时才为1  =>  **`b₃ = a₁ · a₀`**
> >
> > 这四个逻辑表达式正好可以用**四个2输入与门 (AND Gate)** 来实现。而 `Ā₁` 和 `Ā₀` 则需要通过两个**非门 (Inverter)** 来获得。
> >
> > 

---

### Ⅲ. 扩展到通用译码器

> [!cite]
> 同样的原理可以扩展到任意 `n` 位输入的译码器。

> [!check] **3x8 译码器**
> > - **功能**: 3位输入 (`a₂`, `a₁`, `a₀`)，8位输出 (`b₀` 到 `b₇`)。
> > - **实现**: 需要 **3个非门** 和 **8个3输入与门**。
> > - **应用**: 计算机内存寻址。例如，CPU可以用3条地址线，通过一个3x8译码器，来精确地选择8个内存单元中的一个进行读写。

**总结**: 译码器是一种基础的组合逻辑电路，它的核心功能是**将一个紧凑的二进制地址信号，转换为一个唯一的、高电平的选通信号**，在地址解码、指令识别等计算机体系结构领域扮演着至关重要的角色。

![[屏幕截图 2025-08-11 233246.png]]
![[屏幕截图 2025-08-11 234414.png]]

# 笔记：编码器 (Encoder) 原理与实现

> [!abstract] 核心纲要
> 本笔记旨在深入剖析数字逻辑电路中的一个核心组件——**编码器 (Encoder)**。我们将重点关注：
> 1.  **编码器的定义**: 理解其作为**译码器 (Decoder) 的反向操作**，实现“**2ⁿ进n出**”的功能。
> 2.  **实例解析**: 通过**4x2编码器**的例子，理解其工作原理和真值表。
> 3.  **底层实现**: 揭示一个简单的编码器是如何通过**或门 (OR Gate)** 搭建起来的。
> 4.  **关键局限性**: 了解为什么基本编码器要求“**一次只能有一个有效输入**”。

---

### Ⅰ. 编码器是什么？- “反向翻译官”

> [!info]
> **定义**: **编码器 (Encoder)** 是一种数字逻辑电路，它执行与**译码器 (Decoder)** 相反的操作。它能将最多 **`2ⁿ`** 条独立输入线中的**一个**高电平信号，**转换**成一个 `n` 位的二进制输出代码。

> [!example] **一个生动的比喻：键盘控制器**
> > - **`2ⁿ`条输入 (Inputs)**: 想象一个键盘上的多个按键（如A, B, C, D...）。
> > - **编码器 (Encoder)**: 键盘内部的**主控芯片**。
> > - **`n`位输出 (Outputs)**: 芯片输出的二进制代码（**ASCII码**）。
> >
> > **工作流程**: 当你按下键盘上的 **"A" 键**（激活了某一条输入线）时，编码器会接收到这个信号，并在输出端生成字母"A"对应的ASCII二进制码 `01000001`。

---

### Ⅱ. 实例解析：4x2 编码器的工作原理

> [!help]
> - **功能**: 4位输入 (`a₀`, `a₁`, `a₂`, `a₃`)，2位输出 (`b₁`, `b₀`)。
> - **逻辑**: 根据 `a₀` 到 `a₃` 中哪一条线被激活（变为`1`），在输出端 `b₁b₀` 生成对应的二进制代码 `00`, `01`, `10`, 或 `11`。
> - **真值表**:
> ```
>  a₃ | a₂ | a₁ | a₀ | b₁ | b₀
> ----+----+----+----+----+----
>  0  |  0 |  0 |  1 |  0 |  0  -- (a₀=1, 输出 00)
>  0  |  0 |  1 |  0 |  0 |  1  -- (a₁=1, 输出 01)
>  0  |  1 |  0 |  0 |  1 |  0  -- (a₂=1, 输出 10)
>  1  |  0 |  0 |  0 |  1 |  1  -- (a₃=1, 输出 11)
> ```

> [!success] **电路实现：2个或门 (OR Gate)**
> > 我们可以根据真值表，为每一条**输出线**推导出其逻辑表达式：
> >
> > 1. **分析输出 `b₀`**:
> >    - `b₀` 在什么时候为 `1`？观察真值表，当 `a₁=1` **或** `a₃=1` 时，`b₀` 为 `1`。
> >    - **逻辑表达式**: **`b₀ = a₁ + a₃`** (这里的 `+` 代表逻辑“或”)
> >
> > 2. **分析输出 `b₁`**:
> >    - `b₁` 在什么时候为 `1`？观察真值表，当 `a₂=1` **或** `a₃=1` 时，`b₁` 为 `1`。
> >    - **逻辑表达式**: **`b₁ = a₂ + a₃`**
> >
> > 这两个逻辑表达式正好可以用**两个2输入或门 (OR Gate)** 来实现，完美地构成了4x2编码器的内部电路。
> >
> > 

---

### Ⅲ. 关键局限性：一次只能有一个有效输入

> [!danger]
> 像上图这样由简单或门构成的编码器，有一个非常严格的使用前提。

> [!warning] **问题：如果规则被打破会怎样？**
> > **前提**: 在任何给定时间，**只能有一条**输入线被激活（为`1`）。
> >
> > - **情况一：没有输入被激活 (`a₃a₂a₁a₀ = 0000`)**
> >   - `b₀ = 0 + 0 = 0`
> >   - `b₁ = 0 + 0 = 0`
> >   - 输出为 `00`。这个结果与 `a₀` 被激活时的输出**完全相同**。电路无法区分“**没有输入**”和“**输入为0**”这两种情况。
> >
> > - **情况二：多个输入被激活 (例如 `a₁` 和 `a₂` 同时为`1`)**
> >   - 输入为 `0110`。
> >   - `b₀ = a₁ + a₃ = 1 + 0 = 1`
> >   - `b₁ = a₂ + a₃ = 1 + 0 = 1`
> >   - 输出为 `11`。这个结果是 `a₃` 被激活时才会出现的代码。因此，输出是**错误的、无意义的**。

> [!tip] **解决方案：优先编码器 (Priority Encoder)**
> > 为了解决这个局限性，实际应用中通常使用更复杂的**优先编码器**。它内部有额外的逻辑，可以处理多个输入同时被激活的情况，通常会以**输入索引最高**的那个为准进行编码。

![[屏幕截图 2025-08-12 000214.png]]

![[屏幕截图 2025-08-12 000249.png]]

![[屏幕截图 2025-08-12 000319.png]]

![[屏幕截图 2025-08-12 000342.png]]

# 笔记：MUX/DEMUX原理与在处理器中的应用

> [!abstract] 核心纲要
> 本笔记旨在深入剖析**多路复用器 (MUX)** 与**多路解复用器 (DEMUX)** 的核心原理及其在计算机系统中的关键应用。我们将重点关注：
> 1.  **MUX (多路复用器)**: “多选一”数据选择器的功能与逻辑门实现。
> 2.  **DEMUX (多路解复用器)**: “一分多”数据分配器的功能与逻辑门实现。
> 3.  **核心应用**: 详细解析MUX和DEMUX是如何在**处理器（CPU）**内部实现操作数选择和结果路由，以及它们在**内存系统**中的作用。

---

### Ⅰ. 多路复用器 (Multiplexer, MUX) - “数据选择器”

> [!info]
> - **功能**: **多选一 (Many-to-One)**。MUX是一个数字开关，它有 `2ⁿ` 条数据输入线、`n` 条选择线和一个单一的输出线。
> - **工作原理**: 通过 `n` 条**选择线**上的二进制值（地址），来决定将**哪一条**数据输入线连接到唯一的输出线上。

> [!example] **4x1 MUX的内部逻辑实现**
> > - **组件**: 一个4x1 MUX通常由**4个与门 (AND)**、**1个或门 (OR)** 和 **2个非门 (NOT)** 构成。
> > - **工作流程**:
> >   1. **地址解码**: 2条选择线 `s1, s0` 和它们的反向信号，共同构成了一个“地址解码”网络。对于`s1,s0`的任何一个组合（如`10`），**只有**一个对应的与门会被“使能”（允许通过）。
> >   2. **数据选通**: 被使能的那个与门，会将其对应的数据输入线（如`I₂`）上的值传递出去；而所有其他未被使能的与门，输出都为`0`。
> >   3. **输出汇总**: 最终，所有与门的输出汇集到一个或门。因为只有一个与门的输出可能为`1`，所以或门的输出就等于那条被选中的数据输入线的值。
> >
> > 

---

### Ⅱ. 多路解复用器 (Demultiplexer, DEMUX) - “数据分配器”

> [!help]
> - **功能**: **一分多 (One-to-Many)**。DEMUX执行与MUX相反的操作，它有一个单一的数据输入线、`n` 条选择线和 `2ⁿ` 条输出线。
> - **工作原理**: 通过 `n` 条**选择线**上的二进制值（地址），来决定将那条**单一的输入数据**发送到**哪一条**输出线上去。

> [!tip] **1x4 DEMUX的内部逻辑实现**
> > - **组件**: 一个1x4 DEMUX的结构与 **2x4译码器 (Decoder)** 非常相似，可以理解为一个**带有“使能”端**的译码器。
> > - **工作流程**:
> >   1. **地址选择**: 选择线 `a, b` 首先像译码器一样，选中**唯一一条**将要输出的路径。
> >   2. **数据传输**: 单一的数据输入 `F` 充当了所有与门的“总开关”。如果 `F=1`，则被选中的那条输出线输出`1`；如果 `F=0`，则所有输出线都为`0`。
> >



---

### Ⅲ. 实际应用：MUX/DEMUX 在处理器与内存中的角色

> [!success]
> 这些简单的“选择器”和“分配器”是构建复杂计算机系统的核心骨架。

> [!cite] **1. 在处理器 (Processor) 内部**
> > 下图展示了一个简化的处理器数据通路，MUX和DEMUX在其中扮演着“**数据调度总管**”的角色。
> >
> > 
> >
> > - **操作数选择 (MUX)**:
> >   - 处理器中的算术逻辑单元 (ALU) 需要从多个寄存器 (`In₀` - `In₃`) 中选择两个作为输入。
> >   - 图中左侧的**两个MUX**就负责这个任务。控制信号 `SRC1` 和 `SRC2`（即选择线）决定了哪两个寄存器的值被送到ALU进行计算。
> > - **结果路由 (DEMUX)**:
> >   - ALU计算完成后，其**单一的结果**需要被存回到多个目标寄存器 (`Out₀` - `Out₃`) 中的**某一个**。
> >   - 图中右侧的**DEMUX**就负责这个任务。控制信号 `DEST`（即选择线）决定了ALU的计算结果最终被写入哪个目标寄存器。
> >
> > **示例**: `Add In₀ and In₃ and send to Out₂`
> > - MUX 1的选择信号设为 `00`，选中 `In₀`。
> > - MUX 2的选择信号设为 `11`，选中 `In₃`。
> > - ALU的控制信号设为“加法”。
> > - DEMUX的选择信号设为 `10`，将ALU的加法结果路由到 `Out₂`。

> [!cite] **2. 在内存 (Memory) 系统中**
> > - **写入内存 (Write)**: 当CPU要向内存写入数据时，**译码器 (Decoder)** 会根据CPU提供的地址，在成千上万个存储单元中**选中唯一一个**。**多路解复用器 (DEMUX)** 则负责将CPU数据总线上的数据，准确地**分配**到这个被选中的存储单元中。
> > - **读取内存 (Read)**: 当CPU要从内存读取数据时，**多路复用器 (MUX)** 负责从成千上万个存储单元中，**选择**出那个地址被指定的单元的数据，并将其**传送**到CPU的数据总线上。