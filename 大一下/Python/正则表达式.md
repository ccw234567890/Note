# 🐍 Python 正则表达式核心笔记

> [!NOTE] 核心思想：模式匹配的语言
> - **它是什么？** 正则表达式（Regex）是一种**描述文本模式**的微型语言。它本身是一个字符串，但这个字符串并非其字面含义，而是一套规则。
> - **它做什么？** 用于在另一个字符串中**搜索、匹配、提取或替换**符合其规则的部分。
> - **与普通字符串的区别？**
>   -   **字符串 (String)**: 数据的**载体**，是精确的字符序列，所见即所得。
>   -   **正则表达式 (Regex)**: 操作数据的**规则**，定义了一个模式，用于处理一类而非一个特定的文本。
> 
> 在 Python 中，我们通过 `import re` 来使用正则表达式功能。

---

> [!question] 核心语法速查表 (Cheat Sheet)
> | 类别 | 符号 | 含义 & 记忆技巧 | 示例 |
> | :--- | :-- | :--- | :--- |
> | **✨ 基础元字符** | `.` | **点** - 匹配**除换行外**的任意单个字符 | `a.b` → `acb`, `a_b` |
> | | `^` | **尖角** - 匹配字符串的**开头** | `^H` → "**H**ello" |
> | | `$` | **美元** - 匹配字符串的**结尾** | `ld$` → "wor**ld**" |
> | **🔄 量词** | `*` | **星号** - 匹配前一个字符**0次或多次** (任意次) | `go*l` → `gl`, `gol`, `gool` |
> | | `+` | **加号** - 匹配前一个字符**1次或多次** (至少1次) | `go+l` → `gol`, `gool` |
> | | `?` | **问号** - 匹配前一个字符**0次或1次** (可有可无) | `colou?r` → `color`, `colour`|
> | | `{n,m}`| **花括号** - 自定义次数，n到m次 | `\d{2,4}` → `12`, `123`, `1234` |
> | **🔠 字符集** | `\d` | **digit** - 匹配任意一个**数字** `[0-9]` | `\d+` → `12345` |
> | | `\w` | **word** - 匹配**单词字符** (字母、数字、下划线) | `\w+` → `user_01` |
> | | `\s` | **space** - 匹配**空白字符** (空格, tab, 换行) | |
> | | `[...]`| **方括号** - 匹配括号内的**任意一个**字符 | `[aeiou]` → `a`, `e` |
> | | `[^...]`| **^在中括号内** - **取反**，匹配不在括号内的字符 | `[^0-9]` → `a`, `_` |
> | **🧩 分组与逻辑** | `()` | **圆括号** - **分组**，将多个字符视为一个单元 | `(ab)+` → `ab`, `abab` |
> | | `\|` | **竖线** - **或者**，匹配左右两边的任意一个表达式 | `cat\|dog` → `cat`, `dog` |
> | **📍 边界** | `\b` | **boundary** - 匹配**单词边界** (用于精确匹配整个单词) | `\bcat\b` → 精确匹配 "cat" |
> 
> > [!INFO] 大写反义
> > `\D` (非数字), `\W` (非单词字符), `\S` (非空白)。

---

> [!example] Python `re` 模块四大核心函数
> ```python
> import re
> ```
> > [!success]- `re.findall(pattern, string)` -> 查找所有
> > - **用途**：找出所有匹配项，返回一个**列表 (List)**。
> > - **场景**：提取所有URL、所有邮箱、所有数字。
> > - **示例**：提取所有价格数字。
> >   ```python
> >   text = "订单A25价格499元，订单B30价格128元"
> >   prices = re.findall(r'\d+', text)
> >   print(prices)
> >   # 输出: ['25', '499', '30', '128']
> >   ```
>
> > [!abstract]- `re.search(pattern, string)` -> 查找第一个
> > - **用途**：从头到尾搜索，找到**第一个**匹配项就返回一个**匹配对象 (Match Object)**，否则返回 `None`。
> > - **场景**：验证字符串是否符合某种格式（如邮箱、IP地址）。
> > - **示例**：验证并提取邮箱。
> >   ```python
> >   text = "我的邮箱是 example@test.com 请联系我"
> >   match = re.search(r'\w+@\w+\.\w+', text)
> >   if match:
> >       print("找到邮箱:", match.group(0))  # .group(0) 获取整个匹配内容
> >   # 输出: 找到邮箱: example@test.com
> >   ```
>
> > [!warning]- `re.sub(pattern, repl, string)` -> 查找并替换
> > - **用途**：将所有匹配的子串替换成指定内容 (`repl`)。
> > - **场景**：数据清洗、信息脱敏。
> > - **示例**：手机号脱敏。
> >   ```python
> >   phone = "联系方式：13812345678"
> >   # ()分组捕获，\1 \2 用于引用捕获的内容
> >   safe_phone = re.sub(r'(\d{3})\d{4}(\d{4})', r'\1****\2', phone)
> >   print(safe_phone)
> >   # 输出: 联系方式：138****5678
> >   ```
>
> > [!failure]- `re.split(pattern, string)` -> 按模式分割
> > - **用途**：用正则表达式作为分隔符来分割字符串。比 `str.split()` 更强大。
> > - **场景**：处理格式不统一的文本。
> > - **示例**：按多种符号分割。
> >   ```python
> >   log = "user:john; age:25, city:newyork"
> >   fields = re.split(r'[:;,]\s*', log) # 按冒号、分号、逗号及可选空格分割
> >   print(fields)
> >   # 输出: ['user', 'john', 'age', '25', 'city', 'newyork']
> >   ```

---

> [!tip] 实用技巧与最佳实践
> - [ ] **使用原始字符串 (Raw String)**
>   - **做什么**：在正则表达式字符串前加 `r`，例如 `r'\d+'`。
>   - **为什么**：避免 Python 将 `\` 识别为转义字符，导致正则表达式语法错误。**强烈推荐！**
> - [ ] **由简到繁，逐步构建**
>   - 不要一开始就写非常复杂的表达式。先写一个简单的核心部分，测试通过后，再逐步添加更复杂的逻辑。
> - [ ] **利用在线工具调试**
>   - 当表达式复杂或出现问题时，使用 **[Regex101.com](https://regex101.com/)** 等网站。
>   - **优点**：可以实时测试、查看匹配高亮、并有详细的语法解释，是学习和调试的神器。

---

# 🐍 Python 正则表达式实用案例笔记

> [!TIP] 温馨提示
> 点击每个案例标题右侧的箭头可以展开或折叠内容，方便聚焦学习。

---

> [!example]- 示例 1：✅ 验证数据格式（检查邮箱）
> 
> **🎯 场景与目标**
> - **场景**: 用户在网站注册时填写邮箱，程序需要验证其格式是否基本正确。
> - **目标**: 判断一个字符串是否符合 `用户名@域名.顶级域名` 的通用结构。
> 
> **🔍 正则表达式解析**
> > `r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'`
> 
> - `^` : 从字符串**开头**开始匹配。
> - `[a-zA-Z0-9._%+-]+` : 用户名部分。匹配1次或多次由字母、数字及 `._%+-` 组成的字符。
> - `@` : 精确匹配 `@` 符号。
> - `[a-zA-Z0-9.-]+` : 域名部分。匹配1次或多次由字母、数字、点、减号组成的字符。
> - `\.` : 匹配一个真正的点 `.` (因为 `.` 本身是元字符，需转义)。
> - `[a-zA-Z]{2,}` : 顶级域名。匹配至少2个英文字母。
> - `$` : 匹配到字符串的**结尾**。
> 
> **💻 Python 代码与结果**
> ```python
> import re
> 
> def is_valid_email(email):
>     pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
>     if re.search(pattern, email):
>         return True
>     else:
>         return False
> 
> # --- 测试 ---
> print(f"'test.user@example.com' 合法吗? {is_valid_email('test.user@example.com')}")
> print(f"'invalid-email@.com' 合法吗? {is_valid_email('invalid-email@.com')}")
> ```
> > **结果**
> > ```
> > 'test.user@example.com' 合法吗? True
> > 'invalid-email@.com' 合法吗? False
> > ```

---

> [!abstract]- 示例 2：📥 批量提取信息（找出电话号码）
> 
> **🎯 场景与目标**
> - **场景**: 从一大段包含各种信息的客户留言文本中，快速捞出所有的手机号码。
> - **目标**: 使用 `re.findall()` 提取所有11位的手机号码。
> 
> **🔍 正则表达式解析**
> > `r'1[3-9]\d{9}'`
> 
> - `1` : 号码必须以 `1` 开头。
> - `[3-9]` : 第二位是 `3` 到 `9` 之间的任意一个数字。
> - `\d{9}` : 后面跟着9个任意数字 (`\d`代表数字, `{9}`代表重复9次)。
> 
> **💻 Python 代码与结果**
> ```python
> import re
> 
> text = """
> 张三的电话是 13812345678，请尽快联系。
> 李四的备用联系方式为 15987654321，还有一个无效号码 12000000000。
> 王五的号码是18699998888。
> """
> 
> phone_numbers = re.findall(r'1[3-9]\d{9}', text)
> print("提取到的所有手机号码:", phone_numbers)
> ```
> > **结果**
> > ```
> > 提取到的所有手机号码: ['13812345678', '15987654321', '18699998888']
> > ```

---

> [!warning]- 示例 3：🛡️ 替换与脱敏（隐藏身份证号）
> 
> **🎯 场景与目标**
> - **场景**: 在显示或记录日志时，为了保护用户隐私，需要将身份证号的出生日期部分用 `*` 代替。
> - **目标**: 使用 `re.sub()` 和**分组捕获**，替换身份证号中间8位为 `********`。
> 
> **🔍 正则表达式解析**
> > `r'(\d{6})\d{8}(\d{4})'`
> 
> - `(\d{6})` : **第一个分组**。捕获前6位数字。
> - `\d{8}` : 匹配中间的8位数字，**不捕获**，因为要替换掉它。
> - `(\d{4})` : **第二个分组**。捕获后4位数字。
> 
> **💻 Python 代码与结果**
> ```python
> import re
> 
> id_card = "11010519900307735X"
> 
> # 在替换字符串中，\1 和 \2 分别代表第一个和第二个分组捕获到的内容
> desensitized_id = re.sub(r'(\d{6})\d{8}(\d{4})', r'\1********\2', id_card)
> 
> print(f"原始ID: {id_card}")
> print(f"脱敏ID: {desensitized_id}")
> ```
> > **结果**
> > ```
> > 原始ID: 11010519900307735X
> > 脱敏ID: 110105********735X
> > ```

---

> [!bug]- 示例 4：⚙️ 高级数据解析（解析日志文件）
> 
> **🎯 场景与目标**
> - **场景**: 分析服务器访问日志，每行日志都有固定格式，需要从中提取出IP地址、请求时间等结构化信息。
> - **目标**: 使用 `re.search()` 和**命名分组**，像操作字典一样提取数据。
> 
> **🔍 正则表达式解析**
> > `r'(?P<ip>(\d{1,3}\.){3}\d{1,3}).*?\[(?P<time>.*?)\] "(?P<path>.*?)"'`
> 
> - `(?P<ip>...)` : **命名分组** `ip`。`(\d{1,3}\.){3}\d{1,3}` 是一个更严谨的IP匹配模式。
> - `.*?` : 非贪婪匹配任意字符，防止跳过重要部分。
> - `\[(?P<time>.*?)\]` : **命名分组** `time`。`\[` 和 `\]` 匹配方括号本身。
> - `"(?P<path>.*?)"` : **命名分组** `path`。匹配双引号内的内容。
> 
> **💻 Python 代码与结果**
> ```python
> import re
> 
> log_line = '192.168.1.1 - - [13/Jul/2025:20:30:00 +0000] "GET /index.html HTTP/1.1" 200 1234'
> pattern = r'(?P<ip>(\d{1,3}\.){3}\d{1,3}).*?\[(?P<time>.*?)\] "(?P<path>.*?)"'
> 
> match = re.search(pattern, log_line)
> if match:
>     # .groupdict() 一次性获取所有命名分组，返回一个字典
>     log_data = match.groupdict()
>     print("解析结果 (字典):", log_data)
>     
>     # 也可以通过组名单独访问
>     print("\n单独访问IP:", match.group('ip'))
> ```
> > **结果**
> > ```
> > 解析结果 (字典): {'ip': '192.168.1.1', 'time': '13/Jul/2025:20:30:00 +0000', 'path': 'GET /index.html HTTP/1.1'}
> > 
> > 单独访问IP: 192.168.1.1
> > ```