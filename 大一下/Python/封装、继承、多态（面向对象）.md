# 🐍 Python 封装思想：从理论到实践

![[Pasted image 20250714214306.png]]
![[Pasted image 20250714214318.png]]
> [!NOTE] 核心思想
> 这份笔记将两张图串联起来，讲述了同一个故事：**封装 (Encapsulation)**。
> 我们将从“**为什么**要封装”（理论），过渡到“**如何**用代码实现封装”（实践）。

---

> [!abstract]- 第一部分：理论篇 🤔 - 什么是封装？(ATM机的启示)
> 
> **这张图告诉你面向对象编程的三大基石之一：封装。**
> 
> > [!tip] 封装的核心定义
> > **隐藏内部的复杂细节，只对外提供简单的、固定的操作方式。**
> 
> ---
> #### 最佳比喻：ATM机
> 
> - **🔒 隐藏的内部细节**:
>   - 齿轮如何转动
>   - 电路如何工作
>   - 钱是如何被点算的
>   - 如何连接到银行网络
> 
> - **✅ 对外提供的操作接口**:
>   - 插卡口
>   - 屏幕显示
>   - 键盘输入
> 
> **你不需要懂内部原理，只需通过简单的接口就能安全地使用它的核心功能。这就是封装的精髓！**
> 
> ---
> 
> > [!warning] Python的实现方式：下划线权限控制
> > Python 通过变量名前的下划线来约定访问权限：
> > - **`_name` (单下划线)**: **受保护的(protected)**。君子协定，告诉其他程序员：“这是内部变量，你最好别在外部直接用。”
> > - **`__name` (双下划线)**: **私有的(private)**。Python 会对其进行“名字重整”，让外部很难直接访问，起到了强保护作用。**（这是本次代码案例的关键）**
> > - **`__name__` (首尾双下划线)**: Python 官方定义的**特殊方法/魔术方法**，如 `__init__`。

---

> [!example]- 第二部分：实践篇 💻 - 代码如何实现“只读”封装？
> 
> **这段代码完美演示了如何利用“封装”思想，创造一个只能读取、不能随意修改的属性。**
> 
> ```python
> class Student:
>     def __init__(self, name, gender):
>         self.name = name
>         # self.__gender 是私有的实例属性
>         self.__gender = gender
> 
>     # 使用@property修改方法，将方法转成属性使用
>     @property
>     def gender(self):
>         return self.__gender
> 
> stu = Student(name='陈梅梅', gender='女')
> 
> # stu.gender 就会去执行 stu.gender()
> print(stu.name, '的性别是:', stu.gender)
> 
> # 尝试修改只读属性
> stu.gender = '男' # AttributeError: property 'gender' of 'Student' object has no setter
> ```
> 
> ---
> #### 代码分步解析
> 
> > [!bug] 1️⃣ 隐藏内部数据 (锁进保险柜)
> > `self.__gender = gender`
> > - 程序员使用**双下划线 `__`**，明确地将 `__gender` 标记为**私有属性**。
> > - 意图是：“这是内部核心数据，不希望被外部代码随意篡改！”
> 
> > [!success] 2️⃣ 提供“只读”按钮 (`@property`)
> > `@property`
> > `def gender(self):`
> > - 既然数据锁起来了，如何安全地读取它？`@property` 就是那个“**查询按钮**”。
> > - 它把一个 `gender()` **方法**，巧妙地伪装成了一个**属性**。
> > - 这就是封装里“**对外提供操作方式**”的体现。
> 
> > [!check] ✅ 为什么 `print(stu.gender)` 能成功？
> > - 因为当你访问 `stu.gender` 时，`@property` 装饰器会拦截这个操作，并自动调用 `gender()` 方法。
> > - `gender()` 方法进入内部，安全地取出 `self.__gender` 的值并返回。整个过程可控且安全。
> 
> > [!failure] ❌ 为什么 `stu.gender = '男'` 会失败？
> > - 这是封装效果最直接的体现！
> > - 你试图给 `stu.gender` 赋值，但我们只提供了 `@property` 这个“**读取**”按钮，并没有提供“**写入/修改**”的按钮（需要用 `@gender.setter` 装饰器来定义）。
> > - 由于没有写入的通道，Python 拒绝了你的操作，并明确报错：**`AttributeError: ... has no setter`** (没有设置器)。

---

> [!quote] 两张图的联系：一句话总结
> **第一张图**告诉你**“为什么”**要封装（像ATM机一样隐藏细节只留按钮），以及在Python里用下划线来实现。
> 
> **第二张图**向你展示了**“如何”**用代码（`__gender` + `@property`）实现一个“**只能按（读），不能存（写）**”的按钮，从而完美地保护了内部数据不被随意修改。

---

![[Pasted image 20250714214201.png]]

![[Pasted image 20250714214234.png]]
# 🐍 Python 继承思想：从理论到实践

> [!NOTE] 核心思想
> 这份笔记将两张图串联起来，讲述了面向对象编程的第二大特征：**继承 (Inheritance)**。
> 继承的核心是**代码复用**，就像孩子从父母那里继承特征一样，一个“子类”可以自动获得“父类”的所有功能。

---

> [!abstract]- 第一部分：理论篇 🤔 - 什么是继承？(子承父业)
> 
> **这张图告诉你继承的基本概念和规则。**
> 
> > [!tip] 继承的核心定义与比喻
> > - **定义**: 一个**子类 (child class)** 可以自动地、免费地获得另一个**父类 (parent class)** 的所有公共属性和方法。
> > - **最佳比喻**: **生物学上的父子关系**。孩子（子类）继承父母（父类）的特征（代码），并发展出自己的个性（新代码）。
> 
> ---
> #### ✅ 主要目的：代码复用 (Code Reusability)
> 把通用的、重复的代码只写一次（放在父类里），所有子类都能直接使用，无需重复编写，极大提高了开发效率和可维护性。
> 
> ---
> 
> > [!info] Python中的继承规则
> > - **多重继承**: 一个子类可以同时继承多个父类，`class Child(Dad, Mom):`。
> > - **开枝散叶**: 一个父类可以被多个子类继承。
> > - **万物之源**: 如果一个类没有指定父类，它默认继承自 `object` 类。
> > - **基本语法**:
> >   ```python
> >   class 子类名(父类1, 父类2, ...):
> >       pass
> >   ```

---

> [!example]- 第二部分：实践篇 💻 - 代码如何体现“子承父业”？
> 
> **这段代码完美地展示了继承如何实现代码复用和功能扩展。**
> 
> ```python
> # 1. 定义“父类”，提供通用的“家产”
> class Person: # 默认继承了object
>     def __init__(self, name, age):
>         self.name = name
>         self.age = age
> 
>     def show(self):
>         print(f'大家好，我叫:{self.name},我今年:{self.age}岁!')
> 
> # 2. 定义“子类”，继承父类的“家产”
> class Student(Person):
>     # 编写初始化的方法
>     def __init__(self, name, age, stuno):
>         # 3. 调用父类的初始化方法，复用代码
>         super().__init__(name, age) 
>         # 4. 增加自己独特的属性
>         self.stuno = stuno
> 
> # Doctor类的逻辑完全相同
> class Doctor(Person):
>     def __init__(self, name, age, department):
>         super().__init__(name, age)
>         self.department = department
> ```
> 
> ---
> #### 代码分步解析
> 
> > [!NOTE] 1️⃣ 定义“父类” `Person` (提供“家产”)
> > `Person` 类定义了所有“人”都具备的共同属性（`name`, `age`）和共同方法（`show()`）。这是可被复用的“**家产**”。
> 
> > [!done] 2️⃣ 定义“子类” `Student` (继承“家产”)
> > `class Student(Person):` 这行代码声明 `Student` 继承自 `Person`。
> > - **继承的直接好处**: 即使 `Student` 类里空空如也，一个 `Student` 对象也能直接调用父类的 `show()` 方法。这就是**代码复用**！
> >   ```python
> >   stu = Student('小明', 18, 'S001')
> >   stu.show() # ✅ 可以完美执行！
> >   ```
> 
> > [!bug] 3️⃣ 继承并扩展 (`super()` 的妙用)
> > - **问题**: `Student` 比普通的 `Person` 多一个 `stuno`（学号）属性，所以需要自己的 `__init__` 方法。
> > - **思考**: 我们需要在 `Student` 的 `__init__` 中重写 `self.name=name` 和 `self.age=age` 吗？**不需要！**
> > - **解决方案**: 使用 `super()`。
> >   > [!quote] `super().__init__(name, age)` 这句话可以这样理解：
> >   > **“嘿，请我的父类(`Person`)来帮我处理一下 `name` 和 `age` 这两件通用的事，我不想再写一遍了！”**
> > 
> >   `super()` 就像一个神奇的工具，让你能方便地调用父类的方法，是实现代码复用的关键。
> >
> > **完成通用初始化后，子类再添加自己的独特属性 `self.stuno = stuno`，这就实现了“继承并扩展”！**

---

> [!quote] 两张图的联系：一句话总结
> **第一张图**告诉你**“什么是”**继承（子承父业，代码复用）和它的基本语法。
> 
> **第二张图**向你展示了**“如何”**在实践中，让 `Student` 和 `Doctor` 子类通过 `(Person)` 语法**继承**父类的通用方法（如 `show()`），并使用 `super()` 在**扩展**自己功能的同时，还能**复用**父类的初始化代码，完美体现了继承的强大之处。
> 
> > [!INFO] 核心关系
> > 继承在设计上体现了 **"Is-A" (是一个)** 的关系：
> > - A Student **Is A** Person. (学生 **是一个** 人)
> > - A Doctor **Is A** Person. (医生 **是一个** 人)

---
![[Pasted image 20250714220218.png]]
![[Pasted image 20250714220802.png]]
# 🐍 Python 多态思想：从理论到实践

> [!NOTE] 核心思想
> 这份笔记将两张图串联起来，讲述了面向对象编程的第三大特征：**多态 (Polymorphism)**。
> 多态的精髓在于：**不关心类型，只关心行为**。同一个指令，不同的对象去执行，会产生不同的结果。

---

> [!abstract]- 第一部分：理论篇 🤔 - 什么是多态？(多种形态)
> 
> **这张图告诉你多态的基本概念，并点明了Python中多态的独特之处。**
> 
> > [!tip] 多态的核心定义与比喻
> > - **定义**: **多种形态**。即可以在不关心一个变量具体是什么类型的情况下，统一调用它的方法，而程序会在运行时动态决定到底执行哪个对象的哪个方法。
> > - **最佳比喻**: **游戏里的“攻击”指令**。
> >   - 按下同一个“攻击”键 (`attack()`)：
> >   - 如果当前角色是**法师**，他会**念咒语放火球**。
> >   - 如果当前角色是**战士**，他会**拔剑向前挥砍**。
> >   - 指令是统一的，但不同对象执行起来的“形态”是多样的。
> 
> ---
> 
> > [!bug] Python的精髓：🦆 鸭子类型 (Duck Typing)
> > 这是理解Python多态的重中之重！它源于一句名言：
> > > “If it walks like a duck and it quacks like a duck, then it must be a duck.”
> > > （如果一个东西走路像鸭子，叫声也像鸭子，那么它就是一只鸭子。）
> >
> > **在Python中的含义**：
> > **我不管你是什么类型 (`Cat` or `Dog`)，也不管你有没有继承关系，只要你有 `.eat()` 这个方法（能力），我就当你是能‘吃’的东西！**
> >
> > 正如第一张图所说：Python的多态，**只关心行为（方法），不关心类型和继承**。

---

> [!example]- 第二部分：实践篇 💻 - “鸭子类型”是如何工作的？
> 
> **这段代码完美地展示了Python的“鸭子类型”和多态。**
> 
> ```python
> class Cat:
>     def eat(self):
>         print('猫，喜欢吃鱼')
> 
> class Dog:
>     def eat(self):
>         print('狗，喜欢啃骨头')
> 
> # 这个函数不关心传进来的obj到底是什么类型
> def fun(obj):
>     # 它只假设obj一定有.eat()这个方法
>     obj.eat()
> ```
> 
> ---
> #### 代码分步解析
> 
> > [!NOTE] 1️⃣ 准备两个“演员”：`Cat` 和 `Dog`
> > - 我们有两个**完全独立、没有继承关系**的类。
> > - 它们唯一的共同点是，都拥有一个**同名的方法**：`eat()`。
> > - 它们就是两只会用不同方式“叫唤”的“鸭子”。
> 
> > [!success] 2️⃣ 定义一个“通用指令”：`fun(obj)`
> > - `fun(obj)` 函数是一个“**类型不可知**”的通用处理器。
> > - 它对传入的 `obj` 不做任何类型检查。它唯一的“契约”或“期望”是：**“无论你传给我什么，你必须得有 `.eat()` 这个能力！”**
> 
> > [!done] 3️⃣ 开始表演：把不同演员送去执行指令
> > ```python
> > # 创建两个不同的对象
> > cat = Cat()
> > dog = Dog()
> > 
> > # --- 多态的魔力在此展现 ---
> > 
> > print("喂食猫咪:")
> > fun(cat)  # >> 输出: 猫，喜欢吃鱼
> > 
> > print("\n喂食狗狗:")
> > fun(dog)  # >> 输出: 狗，喜欢啃骨头
> > ```
> > > [!question] 幕后的“魔力”是什么？
> > > `fun` 函数的代码一行都没变，但产生了不同的结果。因为：
> > > - 当执行 `fun(cat)` 时，函数内的 `obj` **就是** `cat` 对象，所以 `obj.eat()` 调用的是 `Cat` 类的 `eat` 方法。
> > > - 当执行 `fun(dog)` 时，函数内的 `obj` **就是** `dog` 对象，所以 `obj.eat()` 调用的是 `Dog` 类的 `eat` 方法。
> > >
> > > 究竟调用哪个方法，是在**程序运行时**根据 `obj` 的**实际类型**动态决定的。

---

> [!quote] 两张图的联系：一句话总结
> **第一张图**告诉你**“什么是”**多态（不关心类型，只关心行为/方法），并点出了Python的精髓——**鸭子类型**。
> 
> **第二张图**向你展示了**“如何”**在实践中，让一个通用函数 `fun(obj)` 能够处理任何有 `.eat()` 方法的对象（无论是`Cat`还是`Dog`），因为Python**只认“能力”，不认“身份”**，这完美体现了“鸭子类型”的强大与灵活。